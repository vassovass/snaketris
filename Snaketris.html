<!DOCTYPE html>
<html>

<head>
    <title>SnakeTris</title>
    <style>
        body {
            background: #000;
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        #gameContainer {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin-top: 20px;
        }

        #gameArea {
            position: relative;
        }

        canvas {
            background: #111;
            border: 2px solid #4B0082;
            /* Dark Purple Outline */
        }

        #gameInfo {
            text-align: center;
        }

        #restartButton,
        #instructionsButton,
        #scoreBoardButton,
        #keyBindingsButton,
        #achievementsButton,
        #powerUpsButton {
            display: inline-block;
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #playerNameInput {
            display: block;
            margin: 10px auto;
            padding: 5px;
            font-size: 16px;
        }

        #instructionsModal,
        #scoreBoardModal,
        #keyBindingsModal,
        #achievementsModal,
        #powerUpsModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #instructionsContent,
        #scoreBoardContent,
        #keyBindingsContent,
        #achievementsContent,
        #powerUpsContent {
            background: #222;
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            text-align: left;
        }

        .closeModal {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #alertBox {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 0, 0.9);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            display: none;
            font-size: 18px;
            z-index: 10;
        }

        #controlsDiv {
            margin: 20px;
        }

        #controlsDiv label {
            display: inline-block;
            width: 150px;
            text-align: right;
            margin-right: 10px;
        }

        #controlsDiv input {
            width: 50px;
            text-align: center;
        }

        #nextReward {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }

        #nextBlockCanvas {
            background: #111;
            border: 2px solid #FFD700;
            /* Gold Outline */
            margin-top: 20px;
        }

        #scoreDisplay {
            margin-left: 20px;
            font-size: 18px;
        }

        #snakeSpeedControl {
            margin-top: 10px;
            font-size: 16px;
        }

        #snakeSpeedControl input {
            width: 200px;
        }

        #warpTimeDisplay {
            margin-top: 20px;
            font-size: 18px;
            font-weight: bold;
        }

        #sidebar {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #scoreTable {
            width: 100%;
            border-collapse: collapse;
        }

        #scoreTable th,
        #scoreTable td {
            border: 1px solid #fff;
            padding: 8px;
            text-align: center;
        }

        #keyBindingsContent label {
            display: block;
            margin-top: 10px;
        }

        #keyBindingsContent input {
            width: 50px;
            text-align: center;
            margin-left: 10px;
        }

        #speedIncreaseDisplay {
            margin-top: 10px;
            font-size: 16px;
        }
    </style>
</head>

<body>
    <div id="gameInfo">
        <h1>SnakeTris</h1>
        <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
        <div>
            <button id="restartButton">Start Game</button>
            <button id="instructionsButton">Instructions</button>
            <button id="powerUpsButton">Power-Ups</button>
            <button id="scoreBoardButton">Leaderboard</button>
            <button id="keyBindingsButton">Key Bindings</button>
            <button id="achievementsButton">Achievements</button>
        </div>
    </div>

    <div id="alertBox"></div>

    <div id="gameContainer">
        <div id="gameArea">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div id="sidebar">
            <canvas id="nextBlockCanvas" width="120" height="120"></canvas>
            <div id="scoreDisplay">
                <p id="tetrisScore">Tetris Score: 0</p>
                <p id="snakeScore">Snake Score: 0</p>
                <p id="livesDisplay">Lives: 3</p>
                <div id="warpTimeDisplay"></div>
            </div>
            <div id="snakeSpeedControl">
                <label for="speedSlider">Snake Speed:</label><br>
                <input type="range" id="speedSlider" min="0.25" max="8" step="0.25" value="0.8">
                <span id="speedValue">0.8 blocks/sec</span>
            </div>
            <div id="speedIncreaseDisplay"></div>
            <div id="nextReward">Next Achievement: First Line Clear</div>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructionsModal">
        <div id="instructionsContent">
            <h2>Instructions</h2>
            <p>
                Welcome to <strong>SnakeTris</strong>! This game combines the classic games of <strong>Snake</strong>
                and
                <strong>Tetris</strong> into one exciting challenge.
            </p>
            <h3>Objective:</h3>
            <p>
                Survive as long as possible by controlling the Tetris blocks and the Snake simultaneously. Clear lines
                by
                filling rows with blocks and collect power-ups to enhance your snake.
            </p>
            <h3>Controls:</h3>
            <ul>
                <li>Move Left: <span id="leftKeyDisplay">A</span></li>
                <li>Move Right: <span id="rightKeyDisplay">D</span></li>
                <li>Rotate Clockwise: <span id="rotateCWKeyDisplay">W</span></li>
                <li>Rotate Counter-Clockwise: <span id="rotateCCWKeyDisplay">Q</span></li>
                <li>Soft Drop: <span id="dropKeyDisplay">S</span></li>
            </ul>
            <p>
                Use your mouse to control the snake. The snake will follow your mouse pointer within the game area.
            </p>
            <h3>Game Rules:</h3>
            <h4>Tetris:</h4>
            <p>
                - Blocks (Tetrominoes) will fall from the top. Your goal is to arrange them to fill horizontal
                lines.<br>
                - A line is cleared when you fill a row with <strong>12 consecutive blocks</strong> without gaps.<br>
                - As time progresses, the falling speed of the blocks increases by 10% every minute.<br>
                - You earn points for clearing lines.
            </p>
            <h4>Snake:</h4>
            <p>
                - Control the snake to collect power-ups and avoid collisions.<br>
                - The snake cannot pass through settled Tetris blocks.<br>
                - If the snake collides with itself or a settled block, you lose a life.<br>
                - You start with 3 lives. You can gain extra lives by collecting certain power-ups.
            </p>
            <h3>Power-Ups:</h3>
            <p>
                Various power-ups appear on the game board. Collect them with the snake to gain special abilities. Check
                the
                "Power-Ups" menu for details.
            </p>
            <h3>Scoring System:</h3>
            <p>
                - Clearing a line in Tetris awards you 50 points.<br>
                - Each movement of the snake that increases its length awards 5 points.<br>
                - Collecting power-ups can award or deduct points, depending on the type.
            </p>
            <button class="closeModal" id="closeInstructions">Close</button>
        </div>
    </div>

    <!-- Power-Ups Modal -->
    <div id="powerUpsModal">
        <div id="powerUpsContent">
            <h2>Power-Ups</h2>
            <ul>
                <li><span style="color:#FFA500;">↑</span> Increase Snake Length by 20%</li>
                <li><span style="color:#FF0000;">↓</span> Decrease Snake Length by 30%</li>
                <li><span style="color:#FFFF00;">?</span> Random Effect (Increase or Decrease Snake Length)</li>
                <li><span style="color:#008000;">⇄</span> Side Warp (Wrap around side walls)</li>
                <li><span style="color:#00A000;">⇅</span> Vertical Warp (Wrap around top and bottom walls)</li>
                <li><span style="color:#00C000;">⤡</span> Full Warp (Wrap around all walls)</li>
                <li><span style="color:#FF69B4;">♥</span> Extra Life</li>
            </ul>
            <button class="closeModal" id="closePowerUps">Close</button>
        </div>
    </div>

    <!-- Score Board Modal -->
    <div id="scoreBoardModal">
        <div id="scoreBoardContent">
            <h2>Leaderboard</h2>
            <table id="scoreTable">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Score</th>
                        <th>Date & Time</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Scores will be populated here -->
                </tbody>
            </table>
            <button class="closeModal" id="closeScoreBoard">Close</button>
        </div>
    </div>

    <!-- Key Bindings Modal -->
    <div id="keyBindingsModal">
        <div id="keyBindingsContent">
            <h2>Key Bindings</h2>
            <label>Move Left: <input type="text" id="leftKey" maxlength="1" value="A"></label>
            <label>Move Right: <input type="text" id="rightKey" maxlength="1" value="D"></label>
            <label>Rotate Clockwise: <input type="text" id="rotateCWKey" maxlength="1" value="W"></label>
            <label>Rotate Counter-clockwise: <input type="text" id="rotateCCWKey" maxlength="1" value="Q"></label>
            <label>Soft Drop: <input type="text" id="dropKey" maxlength="1" value="S"></label>
            <button id="saveKeyBindings">Save</button>
            <button class="closeModal" id="closeKeyBindings">Close</button>
        </div>
    </div>

    <!-- Achievements Modal -->
    <div id="achievementsModal">
        <div id="achievementsContent">
            <h2>Achievements</h2>
            <ul id="achievementsList">
                <!-- Achievements will be populated here -->
            </ul>
            <button class="closeModal" id="closeAchievements">Close</button>
        </div>
    </div>

    <script>
        // JavaScript code for the game

        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        // Adjusted game area: Reduce vertical size by 20%
        const originalGridHeight = 20;
        const gridWidth = Math.floor(40 * 1.3); // 4 times wider
        const gridHeight = Math.floor(originalGridHeight * 1.3 * 0.8); // Reduce by 20%
        const blockSize = 30;

        canvas.width = gridWidth * blockSize;
        canvas.height = gridHeight * blockSize;

        let grid = createMatrix(gridWidth, gridHeight);

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }

        // Rainbow colors for Tetris blocks (excluding green shades)
        const rainbowColors = [
            '#FF0000', // Red
            '#FF7F00', // Orange
            '#FFFF00', // Yellow
            '#0000FF', // Blue
            '#4B0082', // Indigo
            '#9400D3'  // Violet
        ];

        const tetrominoes = [
            [
                [1, 1, 1, 1]
            ],
            [
                [1, 0, 0],
                [1, 1, 1]
            ],
            [
                [0, 0, 1],
                [1, 1, 1]
            ],
            [
                [1, 1],
                [1, 1]
            ],
            [
                [0, 1, 1],
                [1, 1, 0]
            ],
            [
                [0, 1, 0],
                [1, 1, 1]
            ],
            [
                [1, 1, 0],
                [0, 1, 1]
            ]
        ];

        let tetrominoBag = [];

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        let tetrominoPlayer = {
            pos: { x: 0, y: 0 },
            matrix: null,
            score: 0,
            color: '#FFFFFF', // Default color
            speed: 1000, // Initial drop interval in milliseconds
        };

        let nextTetromino = null;
        let nextTetrominoColor = '#FFFFFF';

        function tetrominoReset() {
            if (tetrominoPlayer.matrix === null) {
                // First time, initialize both current and next tetromino
                if (tetrominoBag.length === 0) {
                    tetrominoBag = tetrominoes.slice();
                    shuffle(tetrominoBag);
                }
                tetrominoPlayer.matrix = tetrominoBag.pop();
                tetrominoPlayer.color = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
                if (tetrominoBag.length === 0) {
                    tetrominoBag = tetrominoes.slice();
                    shuffle(tetrominoBag);
                }
                nextTetromino = tetrominoBag.pop();
                nextTetrominoColor = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
            } else {
                tetrominoPlayer.matrix = nextTetromino;
                tetrominoPlayer.color = nextTetrominoColor;
                if (tetrominoBag.length === 0) {
                    tetrominoBag = tetrominoes.slice();
                    shuffle(tetrominoBag);
                }
                nextTetromino = tetrominoBag.pop();
                nextTetrominoColor = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
            }
            tetrominoPlayer.pos.y = 0;
            tetrominoPlayer.pos.x = (gridWidth / 2 | 0) - (tetrominoPlayer.matrix[0].length / 2 | 0);
            drawNextTetromino();

            if (collide(grid, tetrominoPlayer)) {
                if (lives > 1) {
                    lives--;
                    updateLivesDisplay();
                    resetSnake();
                    showAlert('You lost a life! Lives remaining: ' + lives);
                } else {
                    lives--;
                    updateLivesDisplay();
                    gameOver = true;
                    updateScoreBoard();
                    alert('Game Over! Tetris block cannot be placed. No lives remaining.');
                }
            }
        }

        let snake = [{ x: Math.floor(gridWidth / 2), y: gridHeight - 1 }];
        let snakeDirection = { x: 0, y: -1 }; // Starts moving upwards
        let snakeNewDirection = { x: 0, y: -1 };
        let snakeScore = 0;
        let snakeLength = 5; // Initial snake length

        let powerUps = []; // Array to hold power-up icons

        // Power-up effects
        let sideWarpEndTime = 0;
        let verticalWarpEndTime = 0;
        let fullWarpEndTime = 0;
        let powerUpDuration = 30000; // Power-up lasts 30 seconds
        let lastWarpPowerUpEndTime = 0; // Last time a warp effect ended
        let lastExtraLifePowerUpTime = 0;

        let lives = 3;
        let paused = false;

        let speedIncreaseInterval = 60000; // 1 minute
        let nextSpeedIncreaseTime = Date.now() + speedIncreaseInterval;

        function resetGame() {
            grid = createMatrix(gridWidth, gridHeight);
            tetrominoPlayer.score = 0;
            tetrominoPlayer.speed = 1000; // Reset speed
            tetrominoPlayer.matrix = null;
            nextTetromino = null;
            snakeScore = 0;
            snakeLength = 5;
            tetrominoReset();
            snake = [{ x: Math.floor(gridWidth / 2), y: gridHeight - 1 }];
            snakeDirection = { x: 0, y: -1 };
            snakeNewDirection = { x: 0, y: -1 };
            powerUps = [];
            sideWarpEndTime = 0;
            verticalWarpEndTime = 0;
            fullWarpEndTime = 0;
            lastWarpPowerUpEndTime = 0;
            lastExtraLifePowerUpTime = 0;
            gameOver = false;
            lastTime = 0;
            dropCounter = 0;
            snakeMoveCounter = 0;
            achievements = {
                'First Line Clear': false,
                'Score 100 Points': false,
                'Survive 5 Minutes': false,
                'Collect 10 Power-Ups': false,
                'Clear 5 Lines': false,
                'Reach Snake Length of 20': false,
                'Collect 20 Power-Ups': false,
                'Clear 10 Lines': false,
                'Score 500 Points': false,
                'Snake Length 50': false
            };
            achievementsUnlocked = [];
            powerUpsCollected = 0;
            linesClearedTotal = 0;
            gameStartTime = Date.now();
            paused = false;
            lives = 3;
            updateLivesDisplay();
            nextSpeedIncreaseTime = Date.now() + speedIncreaseInterval;
            generatePowerUps();
            updateNextRewardDisplay();
            updateScoreDisplays();
            requestAnimationFrame(update);
        }

        const restartButton = document.getElementById('restartButton');
        const playerNameInput = document.getElementById('playerNameInput');
        let playerName = '';

        restartButton.addEventListener('click', () => {
            playerName = playerNameInput.value.trim() || 'Player';
            resetGame();
        });

        // Instructions Modal
        const instructionsButton = document.getElementById('instructionsButton');
        const instructionsModal = document.getElementById('instructionsModal');
        const closeInstructions = document.getElementById('closeInstructions');

        instructionsButton.addEventListener('click', () => {
            updateKeyDisplay();
            instructionsModal.style.display = 'flex';
        });

        closeInstructions.addEventListener('click', () => {
            instructionsModal.style.display = 'none';
        });

        // Power-Ups Modal
        const powerUpsButton = document.getElementById('powerUpsButton');
        const powerUpsModal = document.getElementById('powerUpsModal');
        const closePowerUps = document.getElementById('closePowerUps');

        powerUpsButton.addEventListener('click', () => {
            powerUpsModal.style.display = 'flex';
        });

        closePowerUps.addEventListener('click', () => {
            powerUpsModal.style.display = 'none';
        });

        // Score Board Modal
        const scoreBoardButton = document.getElementById('scoreBoardButton');
        const scoreBoardModal = document.getElementById('scoreBoardModal');
        const closeScoreBoard = document.getElementById('closeScoreBoard');

        scoreBoardButton.addEventListener('click', () => {
            loadScoreBoard();
            scoreBoardModal.style.display = 'flex';
        });

        closeScoreBoard.addEventListener('click', () => {
            scoreBoardModal.style.display = 'none';
        });

        // Key Bindings Modal
        const keyBindingsButton = document.getElementById('keyBindingsButton');
        const keyBindingsModal = document.getElementById('keyBindingsModal');
        const closeKeyBindings = document.getElementById('closeKeyBindings');
        const saveKeyBindings = document.getElementById('saveKeyBindings');

        keyBindingsButton.addEventListener('click', () => {
            keyBindingsModal.style.display = 'flex';
        });

        closeKeyBindings.addEventListener('click', () => {
            keyBindingsModal.style.display = 'none';
        });

        saveKeyBindings.addEventListener('click', () => {
            leftKey = document.getElementById('leftKey').value.toLowerCase();
            rightKey = document.getElementById('rightKey').value.toLowerCase();
            rotateCWKey = document.getElementById('rotateCWKey').value.toLowerCase();
            rotateCCWKey = document.getElementById('rotateCCWKey').value.toLowerCase();
            dropKey = document.getElementById('dropKey').value.toLowerCase();
            updateKeyDisplay();
            keyBindingsModal.style.display = 'none';
        });

        function updateKeyDisplay() {
            document.getElementById('leftKeyDisplay').textContent = leftKey.toUpperCase();
            document.getElementById('rightKeyDisplay').textContent = rightKey.toUpperCase();
            document.getElementById('rotateCWKeyDisplay').textContent = rotateCWKey.toUpperCase();
            document.getElementById('rotateCCWKeyDisplay').textContent = rotateCCWKey.toUpperCase();
            document.getElementById('dropKeyDisplay').textContent = dropKey.toUpperCase();
        }

        // Achievements Modal
        const achievementsButton = document.getElementById('achievementsButton');
        const achievementsModal = document.getElementById('achievementsModal');
        const closeAchievements = document.getElementById('closeAchievements');
        const achievementsList = document.getElementById('achievementsList');

        achievementsButton.addEventListener('click', () => {
            loadAchievements();
            achievementsModal.style.display = 'flex';
        });

        closeAchievements.addEventListener('click', () => {
            achievementsModal.style.display = 'none';
        });

        function loadAchievements() {
            achievementsList.innerHTML = '';
            for (let [key, unlocked] of Object.entries(achievements)) {
                const listItem = document.createElement('li');
                listItem.textContent = `${key}: ${unlocked ? 'Unlocked' : 'Locked'}`;
                achievementsList.appendChild(listItem);
            }
        }

        // Alert Box
        const alertBox = document.getElementById('alertBox');
        let alertTimeout;

        // Default Key Bindings
        let leftKey = 'a';
        let rightKey = 'd';
        let rotateCWKey = 'w';
        let rotateCCWKey = 'q';
        let dropKey = 's';

        let achievements = {
            'First Line Clear': false,
            'Score 100 Points': false,
            'Survive 5 Minutes': false,
            'Collect 10 Power-Ups': false,
            'Clear 5 Lines': false,
            'Reach Snake Length of 20': false,
            'Collect 20 Power-Ups': false,
            'Clear 10 Lines': false,
            'Score 500 Points': false,
            'Snake Length 50': false
        };

        let achievementsUnlocked = [];
        let powerUpsCollected = 0;
        let linesClearedTotal = 0;
        let gameStartTime = Date.now();

        document.addEventListener('keydown', event => {
            if (gameOver || paused) return;

            const key = event.key.toLowerCase();

            // Tetris Controls
            if (key === leftKey) {
                tetrominoMove(-1);
            } else if (key === rightKey) {
                tetrominoMove(1);
            } else if (key === rotateCWKey) {
                rotate(tetrominoPlayer.matrix, 1);
            } else if (key === rotateCCWKey) {
                rotate(tetrominoPlayer.matrix, -1);
            } else if (key === dropKey) {
                // Drop by 5 rows
                for (let i = 0; i < 5; i++) {
                    tetrominoPlayer.pos.y++;
                    if (collide(grid, tetrominoPlayer)) {
                        tetrominoPlayer.pos.y--;
                        merge(grid, tetrominoPlayer);
                        tetrominoReset();
                        let linesCleared = sweep();
                        tetrominoPlayer.score += linesCleared * 50; // Increased points
                        updateScoreDisplays();
                        linesClearedTotal += linesCleared;

                        checkAchievements();

                        break;
                    }
                }
                dropCounter = 0;
            }
        });

        // Mouse Control for Snake
        let mousePosition = { x: snake[0].x * blockSize, y: snake[0].y * blockSize };
        let mouseInCanvas = true;

        canvas.addEventListener('mousemove', event => {
            const rect = canvas.getBoundingClientRect();
            mousePosition = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        });

        canvas.addEventListener('mouseleave', () => {
            mouseInCanvas = false;
            paused = true;
            showAlert('Game Paused: Mouse pointer left the game area!');
        });

        canvas.addEventListener('mouseenter', () => {
            mouseInCanvas = true;
            paused = false;
            hideAlert();
        });

        function tetrominoMove(dir) {
            tetrominoPlayer.pos.x += dir;
            if (collide(grid, tetrominoPlayer)) {
                tetrominoPlayer.pos.x -= dir;
            }
        }

        function tetrominoDrop() {
            tetrominoPlayer.pos.y++;
            if (collide(grid, tetrominoPlayer)) {
                tetrominoPlayer.pos.y--;
                merge(grid, tetrominoPlayer);
                tetrominoReset();
                let linesCleared = sweep();
                tetrominoPlayer.score += linesCleared * 50; // Increased points
                updateScoreDisplays();
                linesClearedTotal += linesCleared;

                checkAchievements();
            }
            dropCounter = 0;
        }

        function rotate(matrix, dir) {
            // Create a deep copy of the matrix
            let rotated = JSON.parse(JSON.stringify(matrix));

            // Transpose the matrix
            for (let y = 0; y < rotated.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [rotated[x][y], rotated[y][x]] = [rotated[y][x], rotated[x][y]];
                }
            }
            // Reverse the rows for clockwise or columns for counter-clockwise rotation
            if (dir > 0) {
                rotated.forEach(row => row.reverse());
            } else {
                rotated.reverse();
            }

            const pos = tetrominoPlayer.pos.x;
            let offset = 1;
            while (collide(grid, { pos: tetrominoPlayer.pos, matrix: rotated })) {
                tetrominoPlayer.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > rotated[0].length) {
                    tetrominoPlayer.pos.x = pos;
                    return;
                }
            }
            tetrominoPlayer.matrix = rotated;
        }

        let gameOver = false;
        let dropCounter = 0;
        let snakeMoveCounter = 0;

        // Adjust snake speed (20% slower)
        let snakeMoveInterval = 200 / 0.8; // milliseconds

        let lastTime = 0;

        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');

        speedSlider.addEventListener('input', () => {
            const speed = parseFloat(speedSlider.value);
            speedValue.textContent = `${speed} blocks/sec`;
            snakeMoveInterval = 1000 / speed;
        });

        function update(time = 0) {
            if (paused) {
                draw();
                requestAnimationFrame(update);
                return;
            }

            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;

            if (dropCounter > tetrominoPlayer.speed) {
                tetrominoDrop();
            }

            if (Date.now() >= nextSpeedIncreaseTime) {
                tetrominoPlayer.speed *= 0.9; // Increase speed by 10%
                nextSpeedIncreaseTime += speedIncreaseInterval;
                showAlert('Tetris speed increased by 10%!');
            }

            // Update countdown display
            let timeUntilSpeedIncrease = Math.ceil((nextSpeedIncreaseTime - Date.now()) / 1000);
            document.getElementById('speedIncreaseDisplay').textContent = `Next speed increase in: ${timeUntilSpeedIncrease}s`;

            snakeMoveCounter += deltaTime;
            if (snakeMoveCounter > snakeMoveInterval) {
                snakeMoveCounter = 0;

                // Mouse Control
                const snakeHead = snake[0];

                if (!mouseInCanvas) {
                    showAlert('Game Paused: Mouse pointer left the game area!');
                } else {
                    const targetX = Math.floor(mousePosition.x / blockSize);
                    const targetY = Math.floor(mousePosition.y / blockSize);
                    const deltaX = targetX - snakeHead.x;
                    const deltaY = targetY - snakeHead.y;

                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        snakeNewDirection = { x: deltaX > 0 ? 1 : -1, y: 0 };
                    } else if (deltaY !== 0) {
                        snakeNewDirection = { x: 0, y: deltaY > 0 ? 1 : -1 };
                    }

                    if (snakeNewDirection.x !== -snakeDirection.x || snakeNewDirection.y !== -snakeDirection.y) {
                        snakeDirection = snakeNewDirection;
                    }

                    let newHead = { x: snakeHead.x + snakeDirection.x, y: snakeHead.y + snakeDirection.y };

                    // Wrap-around logic
                    if (isFullWarpActive() || isSideWarpActive()) {
                        if (newHead.x < 0) {
                            newHead.x = gridWidth - 1;
                        } else if (newHead.x >= gridWidth) {
                            newHead.x = 0;
                        }
                    }
                    if (isFullWarpActive() || isVerticalWarpActive()) {
                        if (newHead.y < 0) {
                            newHead.y = gridHeight - 1;
                        } else if (newHead.y >= gridHeight) {
                            newHead.y = 0;
                        }
                    }

                    // Warning if snake is close to mouse pointer or collision
                    let dx = (newHead.x * blockSize + blockSize / 2) - mousePosition.x;
                    let dy = (newHead.y * blockSize + blockSize / 2) - mousePosition.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < blockSize * 3) {
                        showAlert('Warning: Snake is close to the mouse pointer!');
                    } else if (isNearCollision(newHead)) {
                        showAlert('Warning: Snake is near collision!');
                    } else {
                        hideAlert();
                    }

                    if (
                        (newHead.x < 0 || newHead.x >= gridWidth || newHead.y < 0 || newHead.y >= gridHeight) &&
                        !isFullWarpActive() && !isSideWarpActive() && !isVerticalWarpActive()
                    ) {
                        handleLifeLoss('Snake collision detected.');
                    } else if (
                        snakeCollision(newHead) ||
                        settledBlockCollision(newHead)
                    ) {
                        handleLifeLoss('Snake collision detected.');
                    } else {
                        snake.unshift(newHead);
                        if (snake.length > snakeLength) {
                            snake.pop();
                        } else {
                            snakeScore += 5; // Increased points
                            updateScoreDisplays();
                        }
                        checkPowerUpCollision(newHead);
                    }

                    // Achievement: Survive 5 Minutes
                    if (!achievements['Survive 5 Minutes'] && (Date.now() - gameStartTime) >= 300000) {
                        achievements['Survive 5 Minutes'] = true;
                        showAlert('Achievement Unlocked: Survive 5 Minutes!');
                        updateNextRewardDisplay();
                    }
                }
            }

            draw();
            if (!gameOver) {
                requestAnimationFrame(update);
            }
        }

        function handleLifeLoss(message) {
            if (lives > 1) {
                lives--;
                updateLivesDisplay();
                resetSnake();
                showAlert(`You lost a life! ${message} Lives remaining: ${lives}`);
            } else {
                lives--;
                updateLivesDisplay();
                gameOver = true;
                updateScoreBoard();
                alert(`Game Over! ${message} No lives remaining.`);
            }
        }

        function resetSnake() {
            snake = [{ x: Math.floor(gridWidth / 2), y: gridHeight - 1 }];
            snakeDirection = { x: 0, y: -1 };
            snakeNewDirection = { x: 0, y: -1 };
            snakeLength = 5;
            livesLostDuringThisMove = true;
        }

        function isSideWarpActive() {
            return Date.now() < sideWarpEndTime;
        }

        function isVerticalWarpActive() {
            return Date.now() < verticalWarpEndTime;
        }

        function isFullWarpActive() {
            return Date.now() < fullWarpEndTime;
        }

        function isNearCollision(head) {
            // Check if the snake is near the walls or Tetris blocks
            const directions = [
                { x: -1, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: -1 },
                { x: 0, y: 1 }
            ];
            for (let dir of directions) {
                let x = head.x + dir.x;
                let y = head.y + dir.y;

                // Wrap-around logic
                if (isFullWarpActive() || isSideWarpActive()) {
                    if (x < 0) {
                        x = gridWidth - 1;
                    } else if (x >= gridWidth) {
                        x = 0;
                    }
                }
                if (isFullWarpActive() || isVerticalWarpActive()) {
                    if (y < 0) {
                        y = gridHeight - 1;
                    } else if (y >= gridHeight) {
                        y = 0;
                    }
                }

                if (
                    x < 0 ||
                    x >= gridWidth ||
                    y < 0 ||
                    y >= gridHeight ||
                    settledBlockAt(x, y)
                ) {
                    return true;
                }
            }
            return false;
        }

        function showAlert(message) {
            alertBox.textContent = message;
            alertBox.style.display = 'block';
            clearTimeout(alertTimeout);
            alertTimeout = setTimeout(() => {
                alertBox.style.display = 'none';
            }, 3000); // Increased alert duration
        }

        function hideAlert() {
            alertBox.style.display = 'none';
        }

        function snakeCollision(head) {
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }

        function settledBlockAt(x, y) {
            return grid[y][x] !== 0;
        }

        function settledBlockCollision(head) {
            if (livesLostDuringThisMove) {
                livesLostDuringThisMove = false; // Reset flag
                return false; // Allow passing through settled blocks immediately after life loss
            }
            return settledBlockAt(head.x, head.y);
        }

        let livesLostDuringThisMove = false;

        function collide(grid, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0) {
                        let gridY = y + o.y;
                        let gridX = x + o.x;
                        if (
                            gridY >= gridHeight ||
                            grid[gridY][gridX] !== 0 ||
                            snake.some(segment => segment.x === gridX && segment.y === gridY)
                        ) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        function merge(grid, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        grid[y + player.pos.y][x + player.pos.x] = value;
                    }
                });
            });
        }

        function sweep() {
            let linesCleared = 0;
            for (let y = grid.length - 1; y >= 0; y--) {
                let x = 0;
                while (x < gridWidth) {
                    if (grid[y][x] !== 0) {
                        let runStart = x;
                        let runLength = 1;
                        while (x + runLength < gridWidth && grid[y][x + runLength] !== 0) {
                            runLength++;
                        }
                        if (runLength >= 12) {
                            // Remove the entire row
                            grid.splice(y, 1);
                            grid.unshift(new Array(gridWidth).fill(0));

                            // Remove any power-ups in the cleared line and relocate them
                            powerUps = powerUps.filter(powerUp => {
                                if (powerUp.y === y) {
                                    relocatePowerUp(powerUp);
                                    return false;
                                }
                                return true;
                            });

                            linesCleared++;
                            y++; // Recheck the same line as rows have shifted down
                            break; // Exit the while loop and recheck the same y index
                        }
                        x += runLength;
                    } else {
                        x++;
                    }
                }
            }
            return linesCleared;
        }

        function relocatePowerUp(powerUp) {
            let newLocationFound = false;
            while (!newLocationFound) {
                let newX = Math.floor(Math.random() * gridWidth);
                let newY = Math.floor(Math.random() * gridHeight);
                if (
                    grid[newY][newX] === 0 &&
                    !snake.some(segment => segment.x === newX && segment.y === newY) &&
                    !powerUps.some(p => p.x === newX && p.y === newY)
                ) {
                    powerUp.x = newX;
                    powerUp.y = newY;
                    powerUp.spawnTime = Date.now();
                    newLocationFound = true;
                }
            }
            powerUps.push(powerUp);
        }

        function draw() {
            context.fillStyle = '#000';
            context.fillRect(0, 0, canvas.width, canvas.height);

            drawMatrix(grid, { x: 0, y: 0 });

            drawGhostPiece(); // Draw ghost piece before current tetromino

            // Draw power-ups before Tetris blocks
            drawPowerUps();
            drawMatrix(tetrominoPlayer.matrix, tetrominoPlayer.pos, tetrominoPlayer.color);

            // Draw snake
            snake.forEach((segment, index) => {
                context.fillStyle = index === 0 ? '#FFD700' : '#FFFFFF'; // Head is gold, body is white
                context.fillRect(segment.x * blockSize, segment.y * blockSize, blockSize, blockSize);
            });

            // Indicate horizontal lines with 6 or more blocks
            indicateLines();

            // Draw warp timers outside the play area
            drawWarpTimers();
        }

        function drawMatrix(matrix, offset, color) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        context.fillStyle = color || '#FFFFFF';
                        context.fillRect(
                            (x + offset.x) * blockSize,
                            (y + offset.y) * blockSize,
                            blockSize,
                            blockSize
                        );
                    }
                });
            });
        }

        function indicateLines() {
            context.fillStyle = '#fff';
            context.font = '16px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            for (let y = 0; y < gridHeight; y++) {
                let x = 0;
                while (x < gridWidth) {
                    if (grid[y][x] !== 0) {
                        let runStart = x;
                        let runLength = 1;
                        while (x + runLength < gridWidth && grid[y][x + runLength] !== 0) {
                            runLength++;
                        }
                        if (runLength >= 6 && runLength < 12) {
                            let blocksNeeded = 12 - runLength;
                            // Show numbers on outer blocks
                            context.fillStyle = '#000';
                            context.fillText(blocksNeeded, (runStart + 0.5) * blockSize, (y + 0.5) * blockSize);
                            context.fillText(blocksNeeded, (x + runLength - 0.5) * blockSize, (y + 0.5) * blockSize);
                        }
                        x += runLength;
                    } else {
                        x++;
                    }
                }
            }
        }

        function drawWarpTimers() {
            const warpTimeDisplay = document.getElementById('warpTimeDisplay');
            let activeWarps = [];
            if (isFullWarpActive()) {
                let remainingTime = Math.ceil((fullWarpEndTime - Date.now()) / 1000);
                activeWarps.push(`Full Warp (${remainingTime}s left)`);
            } else {
                if (isSideWarpActive()) {
                    let remainingTime = Math.ceil((sideWarpEndTime - Date.now()) / 1000);
                    activeWarps.push(`Side Warp (${remainingTime}s left)`);
                }
                if (isVerticalWarpActive()) {
                    let remainingTime = Math.ceil((verticalWarpEndTime - Date.now()) / 1000);
                    activeWarps.push(`Vertical Warp (${remainingTime}s left)`);
                }
            }
            if (activeWarps.length > 0) {
                warpTimeDisplay.textContent = `Warp Time Left: ${activeWarps.join(', ')}`;
            } else {
                warpTimeDisplay.textContent = '';
            }
        }

        function drawGhostPiece() {
            let ghostPosition = { ...tetrominoPlayer.pos };
            while (!collide(grid, { pos: ghostPosition, matrix: tetrominoPlayer.matrix })) {
                ghostPosition.y++;
            }
            ghostPosition.y--; // Step back to last valid position

            context.globalAlpha = 0.5;
            drawMatrix(tetrominoPlayer.matrix, ghostPosition, 'grey'); // Draw ghost piece in grey
            context.globalAlpha = 1.0;
        }

        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                const elapsedTime = Date.now() - powerUp.spawnTime;
                if (elapsedTime >= 90000) {
                    // Remove power-up and generate a new one
                    powerUps.splice(powerUps.indexOf(powerUp), 1);
                    generatePowerUps();
                } else {
                    // Handle fading
                    let alpha = 1.0;
                    if (elapsedTime >= 60000) {
                        alpha = 1.0 - ((elapsedTime - 60000) / 30000); // Fade out over 30 seconds
                    }

                    context.globalAlpha = alpha;
                    context.fillStyle = powerUp.color
                    context.fillRect(powerUp.x * blockSize, powerUp.y * blockSize, blockSize, blockSize);
                    context.fillStyle = '#000';
                    context.font = '20px Arial';
                    context.textAlign = 'center';
                    context.textBaseline = 'middle';
                    context.fillText(powerUp.symbol, (powerUp.x + 0.5) * blockSize, (powerUp.y + 0.5) * blockSize);
                    context.globalAlpha = 1.0;
                }
            });
        }

        // Adjusted merge function to handle collision with the snake
        function merge(grid, player) {
            let collisionWithSnake = false;
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        let gridY = y + player.pos.y;
                        let gridX = x + player.pos.x;
                        grid[gridY][gridX] = value;
                        if (snake.some(segment => segment.x === gridX && segment.y === gridY)) {
                            collisionWithSnake = true;
                        }
                    }
                });
            });
            if (collisionWithSnake) {
                handleLifeLoss('Tetris block collided with the snake.');
            }
        }

        // Update the collision function to exclude the snake from tetromino movement
        function collide(grid, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (m[y][x] !== 0) {
                        let gridY = y + o.y; let
                            gridX = x + o.x; if (gridY >= gridHeight ||
                                grid[gridY][gridX] !== 0
                        ) {
                            return true;
                        }
                    }
                }
            }
            return false;
        }

        // Update the instructions content
        document.getElementById('instructionsContent').innerHTML = `
  <h2>Instructions</h2>
  <p>
    Welcome to SnakeTris! This game combines the classic games of Snake and Tetris into one exciting challenge.
  </p>
  <h3>Objective:</h3>
  <p>
    Survive as long as possible by controlling both the falling Tetris blocks and the Snake simultaneously.
    Clear lines by filling rows with blocks and collect power-ups to enhance your snake.
  </p>
  <h3>Tetris Rules:</h3>
  <p>
    Use the keyboard controls to move and rotate the falling Tetris blocks. Fill rows with blocks to clear lines.
    You need at least 12 consecutive blocks in a row to clear a line. The more lines you clear, the higher your score.
    The Tetris blocks speed up every minute, increasing the challenge.
  </p>
  <h3>Snake Rules:</h3>
  <p>
    Control the snake using your mouse. The snake will follow your mouse pointer within the game area.
    Avoid colliding with the walls, your own body, settled Tetris blocks, and falling Tetris blocks.
    Collect power-ups to gain advantages, but be careful—some power-ups can have negative effects.
  </p>
  <h3>Power-Ups:</h3>
  <p>
    Various power-ups appear on the screen. Collect them to gain different effects.
    Check the Power-Ups menu for a full list and explanations of each power-up.
  </p>
  <h3>Scoring:</h3>
  <ul>
    <li>Clearing a line in Tetris: 50 points per line.</li>
    <li>Collecting a positive power-up: Varies (e.g., +10 points).</li>
    <li>Collecting a negative power-up: May deduct points.</li>
    <li>Snake grows longer: Earn points as the snake grows.</li>
  </ul>
  <h3>Controls:</h3>
  <ul>
    <li>Move Left: <span id="leftKeyDisplay">${leftKey.toUpperCase()}</span></li>
    <li>Move Right: <span id="rightKeyDisplay">${rightKey.toUpperCase()}</span></li>
    <li>Rotate Clockwise: <span id="rotateCWKeyDisplay">${rotateCWKey.toUpperCase()}</span></li>
    <li>Rotate Counter-Clockwise: <span id="rotateCCWKeyDisplay">${rotateCCWKey.toUpperCase()}</span></li>
    <li>Soft Drop: <span id="dropKeyDisplay">${dropKey.toUpperCase()}</span></li>
  </ul>
  <button class="closeModal" id="closeInstructions">Close</button>
  `;

        // Event listener for closing instructions modal
        document.getElementById('closeInstructions').addEventListener('click', () => {
            instructionsModal.style.display = 'none';
        });

        // Draw Next Tetromino
        const nextBlockCanvas = document.getElementById('nextBlockCanvas');
        const nextBlockContext = nextBlockCanvas.getContext('2d');

        function drawNextTetromino() {
            nextBlockContext.fillStyle = '#000';
            nextBlockContext.fillRect(0, 0, nextBlockCanvas.width, nextBlockCanvas.height);

            if (nextTetromino) {
                const scale = 20;
                const offset = {
                    x: (nextBlockCanvas.width / 2) - (nextTetromino[0].length * scale) / 2,
                    y: (nextBlockCanvas.height / 2) - (nextTetromino.length * scale) / 2
                };
                nextTetromino.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            nextBlockContext.fillStyle = nextTetrominoColor;
                            nextBlockContext.fillRect(
                                offset.x + x * scale,
                                offset.y + y * scale,
                                scale,
                                scale
                            );
                        }
                    });
                });
            }
        }

        // Start the game when "Start Game" button is clicked
        // resetGame(); // Will be called when "Start Game" is clicked

    </script>
</body>

</html>