<!DOCTYPE html>
<html>

<head>
    <title>Tetris Snake Mashup</title>
    <style>
        body {
            background: #000;
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #111;
            border: 2px solid #4B0082;
            /* Dark Purple Outline */
        }

        #gameInfo {
            text-align: center;
        }

        #restartButton,
        #instructionsButton,
        #scoreBoardButton {
            display: inline-block;
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #playerNameInput {
            display: block;
            margin: 10px auto;
            padding: 5px;
            font-size: 16px;
        }

        #instructionsModal,
        #scoreBoardModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #instructionsContent,
        #scoreBoardContent {
            background: #222;
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
        }

        .closeModal {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #alertBox {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 0, 0.7);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            display: none;
            font-size: 18px;
        }
    </style>
</head>

<body>
    <div id="gameInfo">
        <h1>Tetris Snake Mashup</h1>
        <canvas id="gameCanvas"></canvas>
        <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
        <div>
            <button id="restartButton">Start Game</button>
            <button id="instructionsButton">Instructions</button>
            <button id="scoreBoardButton">Score Board</button>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructionsModal">
        <div id="instructionsContent">
            <h2>Instructions</h2>
            <p><strong>Objective:</strong> Control both the snake and Tetris blocks simultaneously. Avoid collisions
                between the snake and Tetris blocks. Clear lines with Tetris blocks to earn points. Keep the snake alive
                to increase your snake score.</p>
            <h3>Controls</h3>
            <p><strong>Snake Controls:</strong> Arrow Keys</p>
            <p><strong>Tetris Controls:</strong></p>
            <ul>
                <li><strong>Move Left/Right:</strong> A / D</li>
                <li><strong>Rotate:</strong> W (Clockwise) / Q (Counter-clockwise)</li>
                <li><strong>Soft Drop:</strong> S (Press once; holding does not increase speed)</li>
            </ul>
            <h3>Gameplay Mechanics</h3>
            <ul>
                <li>The Tetris block drop speed increases by 1% each time a block is placed.</li>
                <li>The speed resets to the initial value when a new game starts.</li>
                <li>Collect power-ups with the snake:</li>
                <ul>
                    <li><strong>Up Arrow (↑):</strong> Increases snake length by 20% and adds 2 points.</li>
                    <li><strong>Down Arrow (↓):</strong> Decreases snake length by 30% and subtracts 1 point.</li>
                    <li><strong>Question Mark (?):</strong> Randomly increases or decreases snake length.</li>
                </ul>
                <li>An alert appears when the snake is near collision with walls or Tetris blocks.</li>
            </ul>
            <h3>Game Over Conditions</h3>
            <ul>
                <li>Snake collides with walls, Tetris blocks, or itself.</li>
                <li>Tetris blocks reach the top and cannot be placed.</li>
            </ul>
            <button class="closeModal" id="closeInstructions">Close</button>
        </div>
    </div>

    <!-- Score Board Modal -->
    <div id="scoreBoardModal">
        <div id="scoreBoardContent">
            <h2>Score Board</h2>
            <table id="scoreTable">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Score</th>
                        <th>Date</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Scores will be populated here -->
                </tbody>
            </table>
            <button class="closeModal" id="closeScoreBoard">Close</button>
        </div>
    </div>

    <!-- Alert Box -->
    <div id="alertBox"></div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        const gridWidth = 40; // 4 times wider
        const gridHeight = 20;
        const blockSize = 30;

        canvas.width = gridWidth * blockSize;
        canvas.height = gridHeight * blockSize;

        let grid = createMatrix(gridWidth, gridHeight);

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }

        // Rainbow colors for Tetris blocks
        const rainbowColors = [
            '#FF0000', // Red
            '#FF7F00', // Orange
            '#FFFF00', // Yellow
            '#00FF00', // Green
            '#0000FF', // Blue
            '#4B0082', // Indigo
            '#9400D3'  // Violet
        ];

        const tetrominoes = [
            [
                [1, 1, 1, 1]
            ],
            [
                [1, 0, 0],
                [1, 1, 1]
            ],
            [
                [0, 0, 1],
                [1, 1, 1]
            ],
            [
                [1, 1],
                [1, 1]
            ],
            [
                [0, 1, 1],
                [1, 1, 0]
            ],
            [
                [0, 1, 0],
                [1, 1, 1]
            ],
            [
                [1, 1, 0],
                [0, 1, 1]
            ]
        ];

        let tetrominoPlayer = {
            pos: { x: 0, y: 0 },
            matrix: null,
            score: 0,
            color: '#FFFFFF', // Default color
            speed: 1000, // Initial drop interval in milliseconds
        };

        function tetrominoReset() {
            tetrominoPlayer.matrix = tetrominoes[Math.floor(Math.random() * tetrominoes.length)];
            tetrominoPlayer.pos.y = 0;
            tetrominoPlayer.pos.x = (gridWidth / 2 | 0) - (tetrominoPlayer.matrix[0].length / 2 | 0);
            tetrominoPlayer.color = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
            tetrominoPlayer.speed *= 0.99; // Increase speed by 1%

            if (collide(grid, tetrominoPlayer)) {
                gameOver = true;
                updateScoreBoard();
                alert('Game Over! Tetris block cannot be placed.');
            }
        }

        let snake = [{ x: Math.floor(gridWidth / 2), y: gridHeight - 1 }];
        let snakeDirection = { x: 0, y: -1 }; // Starts moving upwards
        let snakeNewDirection = { x: 0, y: -1 };
        let snakeScore = 0;
        let snakeLength = 5; // Initial snake length

        let powerUps = []; // Array to hold power-up icons

        function resetGame() {
            grid = createMatrix(gridWidth, gridHeight);
            tetrominoPlayer.score = 0;
            tetrominoPlayer.speed = 1000; // Reset speed
            snakeScore = 0;
            snakeLength = 5;
            tetrominoReset();
            snake = [{ x: Math.floor(gridWidth / 2), y: gridHeight - 1 }];
            snakeDirection = { x: 0, y: -1 };
            snakeNewDirection = { x: 0, y: -1 };
            powerUps = [];
            gameOver = false;
            lastTime = 0;
            dropCounter = 0;
            snakeMoveCounter = 0;
            generatePowerUps();
            requestAnimationFrame(update);
        }

        const restartButton = document.getElementById('restartButton');
        const playerNameInput = document.getElementById('playerNameInput');
        let playerName = '';

        restartButton.addEventListener('click', () => {
            playerName = playerNameInput.value.trim() || 'Player';
            resetGame();
        });

        // Instructions Modal
        const instructionsButton = document.getElementById('instructionsButton');
        const instructionsModal = document.getElementById('instructionsModal');
        const closeInstructions = document.getElementById('closeInstructions');

        instructionsButton.addEventListener('click', () => {
            instructionsModal.style.display = 'flex';
        });

        closeInstructions.addEventListener('click', () => {
            instructionsModal.style.display = 'none';
        });

        // Score Board Modal
        const scoreBoardButton = document.getElementById('scoreBoardButton');
        const scoreBoardModal = document.getElementById('scoreBoardModal');
        const closeScoreBoard = document.getElementById('closeScoreBoard');

        scoreBoardButton.addEventListener('click', () => {
            loadScoreBoard();
            scoreBoardModal.style.display = 'flex';
        });

        closeScoreBoard.addEventListener('click', () => {
            scoreBoardModal.style.display = 'none';
        });

        // Alert Box
        const alertBox = document.getElementById('alertBox');
        let alertTimeout;

        document.addEventListener('keydown', event => {
            if (gameOver) return;

            // Prevent holding down 'S' key from causing exponential drops
            if (event.repeat && (event.key.toLowerCase() === 's')) {
                return;
            }

            // Snake Controls - Arrow Keys
            if (event.key === 'ArrowLeft') {
                if (snakeDirection.x !== 1) {
                    snakeNewDirection = { x: -1, y: 0 };
                }
            } else if (event.key === 'ArrowUp') {
                if (snakeDirection.y !== 1) {
                    snakeNewDirection = { x: 0, y: -1 };
                }
            } else if (event.key === 'ArrowRight') {
                if (snakeDirection.x !== -1) {
                    snakeNewDirection = { x: 1, y: 0 };
                }
            } else if (event.key === 'ArrowDown') {
                if (snakeDirection.y !== -1) {
                    snakeNewDirection = { x: 0, y: 1 };
                }
            }

            // Tetris Controls - WASD
            else if (event.key.toLowerCase() === 'a') {
                tetrominoMove(-1);
            } else if (event.key.toLowerCase() === 'd') {
                tetrominoMove(1);
            } else if (event.key.toLowerCase() === 's') {
                tetrominoDrop();
            } else if (event.key.toLowerCase() === 'w') {
                rotate(tetrominoPlayer.matrix, 1);
            } else if (event.key.toLowerCase() === 'q') {
                rotate(tetrominoPlayer.matrix, -1);
            }
        });

        function tetrominoMove(dir) {
            tetrominoPlayer.pos.x += dir;
            if (collide(grid, tetrominoPlayer)) {
                tetrominoPlayer.pos.x -= dir;
            }
        }

        function tetrominoDrop() {
            tetrominoPlayer.pos.y++;
            if (collide(grid, tetrominoPlayer)) {
                tetrominoPlayer.pos.y--;
                merge(grid, tetrominoPlayer);
                tetrominoReset();
                let linesCleared = sweep();
                tetrominoPlayer.score += linesCleared * 10;
            }
            dropCounter = 0;
        }

        function rotate(matrix, dir) {
            // Create a deep copy of the matrix
            let rotated = JSON.parse(JSON.stringify(matrix));

            // Transpose the matrix
            for (let y = 0; y < rotated.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [rotated[x][y], rotated[y][x]] = [rotated[y][x], rotated[x][y]];
                }
            }
            // Reverse the rows for clockwise or columns for counter-clockwise rotation
            if (dir > 0) {
                rotated.forEach(row => row.reverse());
            } else {
                rotated.reverse();
            }

            const pos = tetrominoPlayer.pos.x;
            let offset = 1;
            while (collide(grid, { pos: tetrominoPlayer.pos, matrix: rotated })) {
                tetrominoPlayer.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > rotated[0].length) {
                    tetrominoPlayer.pos.x = pos;
                    return;
                }
            }
            tetrominoPlayer.matrix = rotated;
        }

        let gameOver = false;
        let dropCounter = 0;
        let dropInterval = tetrominoPlayer.speed; // milliseconds

        let snakeMoveCounter = 0;
        let snakeMoveInterval = 200; // milliseconds

        let lastTime = 0;

        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;
            dropInterval = tetrominoPlayer.speed;
            if (dropCounter > dropInterval) {
                tetrominoDrop();
            }

            snakeMoveCounter += deltaTime;
            if (snakeMoveCounter > snakeMoveInterval) {
                snakeMoveCounter = 0;
                if (snakeNewDirection.x !== -snakeDirection.x || snakeNewDirection.y !== -snakeDirection.y) {
                    snakeDirection = snakeNewDirection;
                }
                const snakeHead = { x: snake[0].x + snakeDirection.x, y: snake[0].y + snakeDirection.y };

                // Proximity Alert
                if (isNearCollision(snakeHead)) {
                    showAlert('Warning: Snake is near collision!');
                } else {
                    hideAlert();
                }

                if (
                    snakeHead.x < 0 ||
                    snakeHead.x >= gridWidth ||
                    snakeHead.y < 0 ||
                    snakeHead.y >= gridHeight ||
                    grid[snakeHead.y][snakeHead.x] !== 0 ||
                    snakeCollision(snakeHead)
                ) {
                    gameOver = true;
                    updateScoreBoard();
                    alert('Game Over! Snake collision detected.');
                } else {
                    snake.unshift(snakeHead);
                    if (snake.length > snakeLength) {
                        snake.pop();
                    } else {
                        snakeScore += 1;
                    }
                    checkPowerUpCollision(snakeHead);
                }
            }

            draw();
            if (!gameOver) {
                requestAnimationFrame(update);
            }
        }

        function isNearCollision(head) {
            // Check if the snake is near the walls or Tetris blocks
            const directions = [
                { x: -1, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: -1 },
                { x: 0, y: 1 }
            ];
            for (let dir of directions) {
                const x = head.x + dir.x;
                const y = head.y + dir.y;
                if (
                    x < 0 ||
                    x >= gridWidth ||
                    y < 0 ||
                    y >= gridHeight ||
                    grid[y][x] !== 0
                ) {
                    return true;
                }
            }
            return false;
        }

        function showAlert(message) {
            alertBox.textContent = message;
            alertBox.style.display = 'block';
            clearTimeout(alertTimeout);
            alertTimeout = setTimeout(() => {
                alertBox.style.display = 'none';
            }, 2000);
        }

        function hideAlert() {
            alertBox.style.display = 'none';
        }

        function snakeCollision(head) {
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }

        function collide(grid, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (
                        m[y][x] !== 0 &&
                        (grid[y + o.y] && grid[y + o.y][x + o.x]) !== 0
                    ) {
                        return true;
                    }
                }
            }
            return false;
        }

        function merge(grid, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        grid[y + player.pos.y][x + player.pos.x] = value;
                    }
                });
            });
        }

        function sweep() {
            let linesCleared = 0;
            outer: for (let y = grid.length - 1; y >= 0; --y) {
                for (let x = 0; x < grid[y].length; ++x) {
                    if (grid[y][x] === 0) {
                        continue outer;
                    }
                }
                const row = grid.splice(y, 1)[0].fill(0);
                grid.unshift(row);
                ++y;
                linesCleared++;
            }
            return linesCleared;
        }

        function draw() {
            context.fillStyle = '#000';
            context.fillRect(0, 0, canvas.width, canvas.height);

            drawMatrix(grid, { x: 0, y: 0 });
            drawMatrix(tetrominoPlayer.matrix, tetrominoPlayer.pos, tetrominoPlayer.color);

            // Draw power-ups
            powerUps.forEach(powerUp => {
                context.fillStyle = powerUp.color;
                context.fillRect(powerUp.x * blockSize, powerUp.y * blockSize, blockSize, blockSize);
                context.fillStyle = '#000';
                context.font = '20px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(powerUp.symbol, (powerUp.x + 0.5) * blockSize, (powerUp.y + 0.5) * blockSize);
            });

            // Draw snake
            snake.forEach((segment, index) => {
                context.fillStyle = index === 0 ? '#FFD700' : '#FFFFFF'; // Head is gold, body is white
                context.fillRect(segment.x * blockSize, segment.y * blockSize, blockSize, blockSize);
            });

            // Display Scores
            context.fillStyle = '#fff';
            context.font = '16px Arial';
            context.fillText(`Tetris Score: ${tetrominoPlayer.score}`, 10, 20);
            context.fillText(`Snake Score: ${snakeScore}`, 10, 40);
        }

        function drawMatrix(matrix, offset, color) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        context.fillStyle = color || '#FFFFFF';
                        context.fillRect(
                            (x + offset.x) * blockSize,
                            (y + offset.y) * blockSize,
                            blockSize,
                            blockSize
                        );
                    }
                });
            });
        }

        // Power-Up Functions
        function generatePowerUps() {
            powerUps = [];
            const types = [
                { symbol: '↑', effect: 'increase', color: '#00FF00' },
                { symbol: '↓', effect: 'decrease', color: '#FF0000' },
                { symbol: '?', effect: 'random', color: '#FFFF00' }
            ];
            for (let i = 0; i < 5; i++) {
                let powerUp;
                do {
                    powerUp = {
                        x: Math.floor(Math.random() * gridWidth),
                        y: Math.floor(Math.random() * gridHeight),
                        ...types[Math.floor(Math.random() * types.length)]
                    };
                } while (
                    grid[powerUp.y][powerUp.x] !== 0 ||
                    snake.some(segment => segment.x === powerUp.x && segment.y === powerUp.y)
                );
                powerUps.push(powerUp);
            }
        }

        function checkPowerUpCollision(head) {
            for (let i = 0; i < powerUps.length; i++) {
                if (head.x === powerUps[i].x && head.y === powerUps[i].y) {
                    applyPowerUp(powerUps[i]);
                    powerUps.splice(i, 1);
                    // Generate a new power-up
                    generatePowerUps();
                    break;
                }
            }
        }

        function applyPowerUp(powerUp) {
            if (powerUp.effect === 'increase') {
                snakeLength = Math.ceil(snakeLength * 1.2);
                snakeScore += 2;
                showAlert('Snake length increased by 20%! +2 points');
            } else if (powerUp.effect === 'decrease') {
                snakeLength = Math.floor(snakeLength * 0.7);
                snakeScore -= 1;
                showAlert('Snake length decreased by 30%! -1 point');
            } else if (powerUp.effect === 'random') {
                const randomEffect = Math.random() < 0.5 ? 'increase' : 'decrease';
                if (randomEffect === 'increase') {
                    snakeLength = Math.ceil(snakeLength * 1.2);
                    snakeScore += 2;
                    showAlert('Snake length increased by 20%! +2 points');
                } else {
                    snakeLength = Math.floor(snakeLength * 0.7);
                    snakeScore -= 1;
                    showAlert('Snake length decreased by 30%! -1 point');
                }
            }
        }

        // Score Board Management
        function updateScoreBoard() {
            const totalScore = tetrominoPlayer.score + snakeScore;
            const date = new Date().toLocaleDateString();

            const newScore = { name: playerName, score: totalScore, date: date };

            let scores = JSON.parse(localStorage.getItem('tetrisSnakeScores')) || [];
            scores.push(newScore);
            localStorage.setItem('tetrisSnakeScores', JSON.stringify(scores));
        }

        function loadScoreBoard() {
            const scoreTableBody = document.querySelector('#scoreTable tbody');
            scoreTableBody.innerHTML = ''; // Clear existing scores
            let scores = JSON.parse(localStorage.getItem('tetrisSnakeScores')) || [];
            scores.forEach(score => {
                const newRow = document.createElement('tr');

                const nameCell = document.createElement('td');
                nameCell.textContent = score.name;
                newRow.appendChild(nameCell);

                const scoreCell = document.createElement('td');
                scoreCell.textContent = score.score;
                newRow.appendChild(scoreCell);

                const dateCell = document.createElement('td');
                dateCell.textContent = score.date;
                newRow.appendChild(dateCell);

                scoreTableBody.appendChild(newRow);
            });
        }

        // Start the game on page load
        // resetGame();
    </script>
</body>

</html>