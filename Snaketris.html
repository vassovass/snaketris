<!DOCTYPE html>
<html>

<head>
    <title>SnakeTris</title>
    <style>
        body {
            background: #000;
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        #gameContainer {
            display: flex;
            justify-content: center;
            align-items: flex-start;
            margin-top: 20px;
        }

        #gameArea {
            position: relative;
        }

        canvas {
            background: #111;
            border: 2px solid #4B0082;
            /* Dark Purple Outline */
        }

        #gameInfo {
            text-align: center;
        }

        #restartButton,
        #instructionsButton,
        #scoreBoardButton,
        #keyBindingsButton,
        #achievementsButton {
            display: inline-block;
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #playerNameInput {
            display: block;
            margin: 10px auto;
            padding: 5px;
            font-size: 16px;
        }

        #instructionsModal,
        #scoreBoardModal,
        #keyBindingsModal,
        #achievementsModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #instructionsContent,
        #scoreBoardContent,
        #keyBindingsContent,
        #achievementsContent {
            background: #222;
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
            text-align: left;
        }

        .closeModal {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #alertBox {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 0, 0.9);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            display: none;
            font-size: 18px;
            z-index: 10;
        }

        #controlsDiv {
            margin: 20px;
        }

        #controlsDiv label {
            display: inline-block;
            width: 150px;
            text-align: right;
            margin-right: 10px;
        }

        #controlsDiv input {
            width: 50px;
            text-align: center;
        }

        #nextReward {
            margin-top: 20px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }

        #nextBlockCanvas {
            background: #111;
            border: 2px solid #FFD700;
            /* Gold Outline */
            margin-top: 20px;
        }

        #scoreDisplay {
            margin-left: 20px;
            font-size: 18px;
        }

        #snakeSpeedControl {
            margin-top: 10px;
            font-size: 16px;
        }

        #snakeSpeedControl input {
            width: 200px;
        }

        #warpTimeDisplay {
            margin-top: 20px;
            font-size: 18px;
            font-weight: bold;
        }

        #sidebar {
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        #scoreTable {
            width: 100%;
            border-collapse: collapse;
        }

        #scoreTable th,
        #scoreTable td {
            border: 1px solid #fff;
            padding: 8px;
            text-align: center;
        }

        #keyBindingsContent label {
            display: block;
            margin-top: 10px;
        }

        #keyBindingsContent input {
            width: 50px;
            text-align: center;
            margin-left: 10px;
        }
    </style>
</head>

<body>
    <div id="gameInfo">
        <h1>SnakeTris</h1>
        <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
        <div>
            <button id="restartButton">Start Game</button>
            <button id="instructionsButton">Instructions</button>
            <button id="scoreBoardButton">Leaderboard</button>
            <button id="keyBindingsButton">Key Bindings</button>
            <button id="achievementsButton">Achievements</button>
        </div>
    </div>

    <div id="alertBox"></div> <!-- Moved outside gameArea -->

    <div id="gameContainer">
        <div id="gameArea">
            <canvas id="gameCanvas"></canvas>
        </div>
        <div id="sidebar">
            <canvas id="nextBlockCanvas" width="120" height="120"></canvas>
            <div id="scoreDisplay">
                <p id="tetrisScore">Tetris Score: 0</p>
                <p id="snakeScore">Snake Score: 0</p>
                <div id="warpTimeDisplay"></div>
            </div>
            <div id="snakeSpeedControl">
                <label for="speedSlider">Snake Speed:</label><br>
                <input type="range" id="speedSlider" min="0.25" max="8" step="0.25" value="0.8">
                <span id="speedValue">0.8 blocks/sec</span>
            </div>
            <div id="nextReward">Next Achievement: First Line Clear</div>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructionsModal">
        <div id="instructionsContent">
            <h2>Instructions</h2>
            <h3>Objective</h3>
            <p>Control both the snake and Tetris blocks simultaneously. Avoid collisions between the snake and Tetris
                blocks, including the falling block. Clear lines with Tetris blocks to earn points. Keep the snake alive
                to increase your snake score.</p>

            <h3>Controls</h3>
            <ul>
                <li><strong>Snake Controls:</strong> Mouse Pointer (keep the mouse over the game area)</li>
                <li><strong>Tetris Controls:</strong>
                    <ul>
                        <li><strong>Move Left/Right:</strong> <span id="leftKeyDisplay">A</span> / <span
                                id="rightKeyDisplay">D</span></li>
                        <li><strong>Rotate:</strong> <span id="rotateCWKeyDisplay">W</span> (Clockwise) / <span
                                id="rotateCCWKeyDisplay">Q</span> (Counter-clockwise)</li>
                        <li><strong>Soft Drop:</strong> Press <span id="dropKeyDisplay">S</span> (Drops by 5 rows)</li>
                    </ul>
                </li>
            </ul>

            <h3>Gameplay Mechanics</h3>
            <h4>Tetris Rules</h4>
            <ul>
                <li>Tetris blocks change shape every time a new block comes down.</li>
                <li><strong>Ghost Piece:</strong> A shadow shows where the Tetris block will land if dropped directly
                    down.</li>
                <li>Pressing the 'Soft Drop' key will drop the Tetris block by 5 rows.</li>
                <li>The Tetris block drop speed increases by 5% each time a block is placed.</li>
                <li>Any consecutive horizontal line of 12 blocks or more will disappear and earn you points.</li>
                <li><strong>Line Completion Indicators:</strong> If there are 6 or more horizontal blocks together,
                    numbers indicate how many more blocks are needed to clear the line. These numbers are shown on the
                    outer blocks of the line.</li>
            </ul>

            <h4>Snake Rules</h4>
            <ul>
                <li>Control the snake using the mouse pointer.</li>
                <li>The snake moves towards the mouse pointer but cannot reverse direction directly.</li>
                <li>Collect power-ups to alter the snake's length and abilities.</li>
                <li>Avoid colliding with walls (unless warp power-up is active), Tetris blocks (including the falling
                    block), or itself.</li>
            </ul>

            <h3>How to Increase Your Score</h3>
            <ul>
                <li><strong>Tetris Score:</strong> Earn points by clearing lines with Tetris blocks. Each line cleared
                    gives you 10 points.</li>
                <li><strong>Snake Score:</strong> Increase your snake score by surviving longer and collecting
                    power-ups.</li>
            </ul>

            <h3>Power-Ups Key</h3>
            <ul>
                <li><span style="color: #FFA500;">&#x2191;</span> <strong>Up Arrow (↑):</strong> Increases snake length
                    by 20% and adds 2 points.</li>
                <li><span style="color: #FF0000;">&#x2193;</span> <strong>Down Arrow (↓):</strong> Decreases snake
                    length by 30% and subtracts 1 point.</li>
                <li><span style="color: #FFFF00;">?</span> <strong>Question Mark (?):</strong> Randomly increases or
                    decreases snake length.</li>
            </ul>

            <h3>Warp Power-Ups</h3>
            <ul>
                <li><span style="color: #008000;">&#x21C4;</span> <strong>Side Warp (⇄):</strong> Allows snake to wrap
                    around side walls for 30 seconds.</li>
                <li><span style="color: #00A000;">&#x21C5;</span> <strong>Vertical Warp (⇅):</strong> Allows snake to
                    wrap around top and bottom walls for 30 seconds.</li>
                <li><span style="color: #00C000;">&#x2941;</span> <strong>Full Warp (⤡):</strong> Allows snake to wrap
                    around all walls for 30 seconds.</li>
            </ul>

            <h3>Warnings</h3>
            <ul>
                <li>An alert appears when the snake is near collision with walls, Tetris blocks, or the mouse pointer.
                </li>
                <li>A warning appears if the mouse pointer leaves the game area during play.</li>
            </ul>

            <h3>Game Over Conditions</h3>
            <ul>
                <li>Snake collides with walls (unless warp power-up is active), Tetris blocks (including the falling
                    block), or itself.</li>
                <li>Tetris blocks reach the top and cannot be placed.</li>
            </ul>

            <button class="closeModal" id="closeInstructions">Close</button>
        </div>
    </div>

    <!-- Score Board Modal -->
    <div id="scoreBoardModal">
        <div id="scoreBoardContent">
            <h2>Leaderboard</h2>
            <table id="scoreTable">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Score</th>
                        <th>Date & Time</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Scores will be populated here -->
                </tbody>
            </table>
            <button class="closeModal" id="closeScoreBoard">Close</button>
        </div>
    </div>

    <!-- Key Bindings Modal -->
    <div id="keyBindingsModal">
        <div id="keyBindingsContent">
            <h2>Key Bindings</h2>
            <label>Move Left: <input type="text" id="leftKey" maxlength="1" value="A"></label>
            <label>Move Right: <input type="text" id="rightKey" maxlength="1" value="D"></label>
            <label>Rotate Clockwise: <input type="text" id="rotateCWKey" maxlength="1" value="W"></label>
            <label>Rotate Counter-clockwise: <input type="text" id="rotateCCWKey" maxlength="1" value="Q"></label>
            <label>Soft Drop: <input type="text" id="dropKey" maxlength="1" value="S"></label>
            <button id="saveKeyBindings">Save</button>
            <button class="closeModal" id="closeKeyBindings">Close</button>
        </div>
    </div>

    <!-- Achievements Modal -->
    <div id="achievementsModal">
        <div id="achievementsContent">
            <h2>Achievements</h2>
            <ul id="achievementsList">
                <!-- Achievements will be populated here -->
            </ul>
            <button class="closeModal" id="closeAchievements">Close</button>
        </div>
    </div>

    <script>
        // JavaScript code for the game

        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        // Adjusted game area: Reduce vertical size by 20%
        const originalGridHeight = 20;
        const gridWidth = Math.floor(40 * 1.3); // 4 times wider
        const gridHeight = Math.floor(originalGridHeight * 1.3 * 0.8); // Reduce by 20%
        const blockSize = 30;

        canvas.width = gridWidth * blockSize;
        canvas.height = gridHeight * blockSize;

        let grid = createMatrix(gridWidth, gridHeight);

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }

        // Rainbow colors for Tetris blocks (excluding green shades)
        const rainbowColors = [
            '#FF0000', // Red
            '#FF7F00', // Orange
            '#FFFF00', // Yellow
            '#0000FF', // Blue
            '#4B0082', // Indigo
            '#9400D3'  // Violet
        ];

        const tetrominoes = [
            [
                [1, 1, 1, 1]
            ],
            [
                [1, 0, 0],
                [1, 1, 1]
            ],
            [
                [0, 0, 1],
                [1, 1, 1]
            ],
            [
                [1, 1],
                [1, 1]
            ],
            [
                [0, 1, 1],
                [1, 1, 0]
            ],
            [
                [0, 1, 0],
                [1, 1, 1]
            ],
            [
                [1, 1, 0],
                [0, 1, 1]
            ]
        ];

        let tetrominoBag = [];

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        let tetrominoPlayer = {
            pos: { x: 0, y: 0 },
            matrix: null,
            score: 0,
            color: '#FFFFFF', // Default color
            speed: 1000, // Initial drop interval in milliseconds
        };

        let nextTetromino = null;
        let nextTetrominoColor = '#FFFFFF';

        function tetrominoReset() {
            if (tetrominoPlayer.matrix === null) {
                // First time, initialize both current and next tetromino
                if (tetrominoBag.length === 0) {
                    tetrominoBag = tetrominoes.slice();
                    shuffle(tetrominoBag);
                }
                tetrominoPlayer.matrix = tetrominoBag.pop();
                tetrominoPlayer.color = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
                if (tetrominoBag.length === 0) {
                    tetrominoBag = tetrominoes.slice();
                    shuffle(tetrominoBag);
                }
                nextTetromino = tetrominoBag.pop();
                nextTetrominoColor = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
            } else {
                tetrominoPlayer.matrix = nextTetromino;
                tetrominoPlayer.color = nextTetrominoColor;
                if (tetrominoBag.length === 0) {
                    tetrominoBag = tetrominoes.slice();
                    shuffle(tetrominoBag);
                }
                nextTetromino = tetrominoBag.pop();
                nextTetrominoColor = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
            }
            tetrominoPlayer.pos.y = 0;
            tetrominoPlayer.pos.x = (gridWidth / 2 | 0) - (tetrominoPlayer.matrix[0].length / 2 | 0);
            tetrominoPlayer.speed *= 0.95; // Increase speed by 5%
            drawNextTetromino();

            if (collide(grid, tetrominoPlayer)) {
                gameOver = true;
                updateScoreBoard();
                alert('Game Over! Tetris block cannot be placed.');
            }
        }

        let snake = [{ x: Math.floor(gridWidth / 2), y: gridHeight - 1 }];
        let snakeDirection = { x: 0, y: -1 }; // Starts moving upwards
        let snakeNewDirection = { x: 0, y: -1 };
        let snakeScore = 0;
        let snakeLength = 5; // Initial snake length

        let powerUps = []; // Array to hold power-up icons

        // Power-up effects
        let sideWarpEndTime = 0;
        let verticalWarpEndTime = 0;
        let fullWarpEndTime = 0;
        let powerUpDuration = 30000; // Power-up lasts 30 seconds
        let lastWarpPowerUpEndTime = 0; // Last time a warp effect ended

        function resetGame() {
            grid = createMatrix(gridWidth, gridHeight);
            tetrominoPlayer.score = 0;
            tetrominoPlayer.speed = 1000; // Reset speed
            tetrominoPlayer.matrix = null;
            nextTetromino = null;
            snakeScore = 0;
            snakeLength = 5;
            tetrominoReset();
            snake = [{ x: Math.floor(gridWidth / 2), y: gridHeight - 1 }];
            snakeDirection = { x: 0, y: -1 };
            snakeNewDirection = { x: 0, y: -1 };
            powerUps = [];
            sideWarpEndTime = 0;
            verticalWarpEndTime = 0;
            fullWarpEndTime = 0;
            lastWarpPowerUpEndTime = 0;
            gameOver = false;
            lastTime = 0;
            dropCounter = 0;
            snakeMoveCounter = 0;
            achievements = {
                'First Line Clear': false,
                'Score 100 Points': false,
                'Survive 5 Minutes': false,
                'Collect 10 Power-Ups': false,
                'Clear 5 Lines': false,
                'Reach Snake Length of 20': false
            };
            achievementsUnlocked = [];
            powerUpsCollected = 0;
            linesClearedTotal = 0;
            gameStartTime = Date.now();
            generatePowerUps();
            updateNextRewardDisplay();
            updateScoreDisplays();
            requestAnimationFrame(update);
        }

        const restartButton = document.getElementById('restartButton');
        const playerNameInput = document.getElementById('playerNameInput');
        let playerName = '';

        restartButton.addEventListener('click', () => {
            playerName = playerNameInput.value.trim() || 'Player';
            resetGame();
        });

        // Instructions Modal
        const instructionsButton = document.getElementById('instructionsButton');
        const instructionsModal = document.getElementById('instructionsModal');
        const closeInstructions = document.getElementById('closeInstructions');

        instructionsButton.addEventListener('click', () => {
            updateKeyDisplay();
            instructionsModal.style.display = 'flex';
        });

        closeInstructions.addEventListener('click', () => {
            instructionsModal.style.display = 'none';
        });

        // Score Board Modal
        const scoreBoardButton = document.getElementById('scoreBoardButton');
        const scoreBoardModal = document.getElementById('scoreBoardModal');
        const closeScoreBoard = document.getElementById('closeScoreBoard');

        scoreBoardButton.addEventListener('click', () => {
            loadScoreBoard();
            scoreBoardModal.style.display = 'flex';
        });

        closeScoreBoard.addEventListener('click', () => {
            scoreBoardModal.style.display = 'none';
        });

        // Key Bindings Modal
        const keyBindingsButton = document.getElementById('keyBindingsButton');
        const keyBindingsModal = document.getElementById('keyBindingsModal');
        const closeKeyBindings = document.getElementById('closeKeyBindings');
        const saveKeyBindings = document.getElementById('saveKeyBindings');

        keyBindingsButton.addEventListener('click', () => {
            keyBindingsModal.style.display = 'flex';
        });

        closeKeyBindings.addEventListener('click', () => {
            keyBindingsModal.style.display = 'none';
        });

        saveKeyBindings.addEventListener('click', () => {
            leftKey = document.getElementById('leftKey').value.toLowerCase();
            rightKey = document.getElementById('rightKey').value.toLowerCase();
            rotateCWKey = document.getElementById('rotateCWKey').value.toLowerCase();
            rotateCCWKey = document.getElementById('rotateCCWKey').value.toLowerCase();
            dropKey = document.getElementById('dropKey').value.toLowerCase();
            updateKeyDisplay();
            keyBindingsModal.style.display = 'none';
        });

        function updateKeyDisplay() {
            document.getElementById('leftKeyDisplay').textContent = leftKey.toUpperCase();
            document.getElementById('rightKeyDisplay').textContent = rightKey.toUpperCase();
            document.getElementById('rotateCWKeyDisplay').textContent = rotateCWKey.toUpperCase();
            document.getElementById('rotateCCWKeyDisplay').textContent = rotateCCWKey.toUpperCase();
            document.getElementById('dropKeyDisplay').textContent = dropKey.toUpperCase();
        }

        // Achievements Modal
        const achievementsButton = document.getElementById('achievementsButton');
        const achievementsModal = document.getElementById('achievementsModal');
        const closeAchievements = document.getElementById('closeAchievements');
        const achievementsList = document.getElementById('achievementsList');

        achievementsButton.addEventListener('click', () => {
            loadAchievements();
            achievementsModal.style.display = 'flex';
        });

        closeAchievements.addEventListener('click', () => {
            achievementsModal.style.display = 'none';
        });

        function loadAchievements() {
            achievementsList.innerHTML = '';
            for (let [key, unlocked] of Object.entries(achievements)) {
                const listItem = document.createElement('li');
                listItem.textContent = `${key}: ${unlocked ? 'Unlocked' : 'Locked'}`;
                achievementsList.appendChild(listItem);
            }
        }

        // Alert Box
        const alertBox = document.getElementById('alertBox');
        let alertTimeout;

        // Default Key Bindings
        let leftKey = 'a';
        let rightKey = 'd';
        let rotateCWKey = 'w';
        let rotateCCWKey = 'q';
        let dropKey = 's';

        let achievements = {
            'First Line Clear': false,
            'Score 100 Points': false,
            'Survive 5 Minutes': false,
            'Collect 10 Power-Ups': false,
            'Clear 5 Lines': false,
            'Reach Snake Length of 20': false
        };

        let achievementsUnlocked = [];
        let powerUpsCollected = 0;
        let linesClearedTotal = 0;
        let gameStartTime = Date.now();

        document.addEventListener('keydown', event => {
            if (gameOver) return;

            const key = event.key.toLowerCase();

            // Tetris Controls
            if (key === leftKey) {
                tetrominoMove(-1);
            } else if (key === rightKey) {
                tetrominoMove(1);
            } else if (key === rotateCWKey) {
                rotate(tetrominoPlayer.matrix, 1);
            } else if (key === rotateCCWKey) {
                rotate(tetrominoPlayer.matrix, -1);
            } else if (key === dropKey) {
                // Drop by 5 rows
                for (let i = 0; i < 5; i++) {
                    tetrominoPlayer.pos.y++;
                    if (collide(grid, tetrominoPlayer)) {
                        tetrominoPlayer.pos.y--;
                        merge(grid, tetrominoPlayer);
                        tetrominoReset();
                        let linesCleared = sweep();
                        tetrominoPlayer.score += linesCleared * 10;
                        updateScoreDisplays();
                        linesClearedTotal += linesCleared;

                        checkAchievements();

                        break;
                    }
                }
                dropCounter = 0;
            }
        });

        // Mouse Control for Snake
        let mousePosition = { x: snake[0].x * blockSize, y: snake[0].y * blockSize };
        let mouseInCanvas = true;

        canvas.addEventListener('mousemove', event => {
            const rect = canvas.getBoundingClientRect();
            mousePosition = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        });

        canvas.addEventListener('mouseleave', () => {
            mouseInCanvas = false;
            showAlert('Warning: Mouse pointer left the game area!');
        });

        canvas.addEventListener('mouseenter', () => {
            mouseInCanvas = true;
            hideAlert();
        });

        function tetrominoMove(dir) {
            tetrominoPlayer.pos.x += dir;
            if (collide(grid, tetrominoPlayer)) {
                tetrominoPlayer.pos.x -= dir;
            }
        }

        function tetrominoDrop() {
            tetrominoPlayer.pos.y++;
            if (collide(grid, tetrominoPlayer)) {
                tetrominoPlayer.pos.y--;
                merge(grid, tetrominoPlayer);
                tetrominoReset();
                let linesCleared = sweep();
                tetrominoPlayer.score += linesCleared * 10;
                updateScoreDisplays();
                linesClearedTotal += linesCleared;

                checkAchievements();
            }
            dropCounter = 0;
        }

        function rotate(matrix, dir) {
            // Create a deep copy of the matrix
            let rotated = JSON.parse(JSON.stringify(matrix));

            // Transpose the matrix
            for (let y = 0; y < rotated.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [rotated[x][y], rotated[y][x]] = [rotated[y][x], rotated[x][y]];
                }
            }
            // Reverse the rows for clockwise or columns for counter-clockwise rotation
            if (dir > 0) {
                rotated.forEach(row => row.reverse());
            } else {
                rotated.reverse();
            }

            const pos = tetrominoPlayer.pos.x;
            let offset = 1;
            while (collide(grid, { pos: tetrominoPlayer.pos, matrix: rotated })) {
                tetrominoPlayer.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > rotated[0].length) {
                    tetrominoPlayer.pos.x = pos;
                    return;
                }
            }
            tetrominoPlayer.matrix = rotated;
        }

        let gameOver = false;
        let dropCounter = 0;
        let snakeMoveCounter = 0;

        // Adjust snake speed (20% slower)
        let snakeMoveInterval = 200 / 0.8; // milliseconds

        let lastTime = 0;

        const speedSlider = document.getElementById('speedSlider');
        const speedValue = document.getElementById('speedValue');

        speedSlider.addEventListener('input', () => {
            const speed = parseFloat(speedSlider.value);
            speedValue.textContent = `${speed} blocks/sec`;
            snakeMoveInterval = 1000 / speed;
        });

        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;

            if (dropCounter > tetrominoPlayer.speed) {
                tetrominoDrop();
            }

            snakeMoveCounter += deltaTime;
            if (snakeMoveCounter > snakeMoveInterval) {
                snakeMoveCounter = 0;

                // Mouse Control
                const snakeHead = snake[0];

                if (!mouseInCanvas) {
                    showAlert('Warning: Mouse pointer left the game area!');
                } else {
                    const targetX = Math.floor(mousePosition.x / blockSize);
                    const targetY = Math.floor(mousePosition.y / blockSize);
                    const deltaX = targetX - snakeHead.x;
                    const deltaY = targetY - snakeHead.y;

                    if (Math.abs(deltaX) > Math.abs(deltaY)) {
                        snakeNewDirection = { x: deltaX > 0 ? 1 : -1, y: 0 };
                    } else if (deltaY !== 0) {
                        snakeNewDirection = { x: 0, y: deltaY > 0 ? 1 : -1 };
                    }

                    if (snakeNewDirection.x !== -snakeDirection.x || snakeNewDirection.y !== -snakeDirection.y) {
                        snakeDirection = snakeNewDirection;
                    }

                    let newHead = { x: snakeHead.x + snakeDirection.x, y: snakeHead.y + snakeDirection.y };

                    // Wrap-around logic
                    if (isFullWarpActive() || isSideWarpActive()) {
                        if (newHead.x < 0) {
                            newHead.x = gridWidth - 1;
                        } else if (newHead.x >= gridWidth) {
                            newHead.x = 0;
                        }
                    }
                    if (isFullWarpActive() || isVerticalWarpActive()) {
                        if (newHead.y < 0) {
                            newHead.y = gridHeight - 1;
                        } else if (newHead.y >= gridHeight) {
                            newHead.y = 0;
                        }
                    }

                    // Warning if snake is close to mouse pointer or collision
                    let dx = (newHead.x * blockSize + blockSize / 2) - mousePosition.x;
                    let dy = (newHead.y * blockSize + blockSize / 2) - mousePosition.y;
                    let distance = Math.sqrt(dx * dx + dy * dy);
                    if (distance < blockSize * 3) { // Increased alert distance
                        showAlert('Warning: Snake is close to the mouse pointer!');
                    } else if (isNearCollision(newHead)) {
                        showAlert('Warning: Snake is near collision!');
                    } else {
                        hideAlert();
                    }

                    if (
                        (newHead.x < 0 || newHead.x >= gridWidth || newHead.y < 0 || newHead.y >= gridHeight) &&
                        !isFullWarpActive() && !isSideWarpActive() && !isVerticalWarpActive()
                    ) {
                        gameOver = true;
                        updateScoreBoard();
                        alert('Game Over! Snake collision detected.');
                    } else if (
                        grid[newHead.y][newHead.x] !== 0 ||
                        snakeCollision(newHead) ||
                        tetrominoCollision(newHead)
                    ) {
                        gameOver = true;
                        updateScoreBoard();
                        alert('Game Over! Snake collision detected.');
                    } else {
                        snake.unshift(newHead);
                        if (snake.length > snakeLength) {
                            snake.pop();
                        } else {
                            snakeScore += 1;
                            updateScoreDisplays();
                        }
                        checkPowerUpCollision(newHead);
                    }

                    // Achievement: Survive 5 Minutes
                    if (!achievements['Survive 5 Minutes'] && (Date.now() - gameStartTime) >= 300000) {
                        achievements['Survive 5 Minutes'] = true;
                        showAlert('Achievement Unlocked: Survive 5 Minutes!');
                        updateNextRewardDisplay();
                    }
                }
            }

            draw();
            if (!gameOver) {
                requestAnimationFrame(update);
            }
        }

        function isSideWarpActive() {
            return Date.now() < sideWarpEndTime;
        }

        function isVerticalWarpActive() {
            return Date.now() < verticalWarpEndTime;
        }

        function isFullWarpActive() {
            return Date.now() < fullWarpEndTime;
        }

        function isNearCollision(head) {
            // Check if the snake is near the walls or Tetris blocks
            const directions = [
                { x: -1, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: -1 },
                { x: 0, y: 1 }
            ];
            for (let dir of directions) {
                let x = head.x + dir.x;
                let y = head.y + dir.y;

                // Wrap-around logic
                if (isFullWarpActive() || isSideWarpActive()) {
                    if (x < 0) {
                        x = gridWidth - 1;
                    } else if (x >= gridWidth) {
                        x = 0;
                    }
                }
                if (isFullWarpActive() || isVerticalWarpActive()) {
                    if (y < 0) {
                        y = gridHeight - 1;
                    } else if (y >= gridHeight) {
                        y = 0;
                    }
                }

                if (
                    x < 0 ||
                    x >= gridWidth ||
                    y < 0 ||
                    y >= gridHeight ||
                    grid[y][x] !== 0 ||
                    tetrominoContainsCell(x, y)
                ) {
                    return true;
                }
            }
            return false;
        }

        function showAlert(message) {
            alertBox.textContent = message;
            alertBox.style.display = 'block';
            clearTimeout(alertTimeout);
            alertTimeout = setTimeout(() => {
                alertBox.style.display = 'none';
            }, 3000); // Increased alert duration
        }

        function hideAlert() {
            alertBox.style.display = 'none';
        }

        function snakeCollision(head) {
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }

        function tetrominoCollision(head) {
            return tetrominoContainsCell(head.x, head.y);
        }

        function tetrominoContainsCell(x, y) {
            const m = tetrominoPlayer.matrix;
            const o = tetrominoPlayer.pos;
            for (let i = 0; i < m.length; ++i) {
                for (let j = 0; j < m[i].length; ++j) {
                    if (m[i][j] !== 0 && x === j + o.x && y === i + o.y) {
                        return true;
                    }
                }
            }
            return false;
        }

        function collide(grid, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (
                        m[y][x] !== 0 &&
                        (grid[y + o.y] && grid[y + o.y][x + o.x]) !== 0
                    ) {
                        return true;
                    }
                }
            }
            return false;
        }

        function merge(grid, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        grid[y + player.pos.y][x + player.pos.x] = value;
                    }
                });
            });
        }

        function sweep() {
            let linesCleared = 0;
            for (let y = grid.length - 1; y >= 0; --y) {
                let x = 0;
                while (x < grid[y].length) {
                    if (grid[y][x] !== 0) {
                        let runStart = x;
                        let runLength = 1;
                        while (x + runLength < grid[y].length && grid[y][x + runLength] !== 0) {
                            runLength++;
                        }
                        if (runLength >= 12) {
                            // Remove blocks from x to x + runLength - 1
                            for (let k = x; k < x + runLength; k++) {
                                grid[y][k] = 0;
                            }
                            linesCleared++;

                            // Remove any power-ups in the cleared line and relocate them
                            powerUps = powerUps.filter(powerUp => {
                                if (powerUp.y === y && powerUp.x >= x && powerUp.x < x + runLength) {
                                    relocatePowerUp(powerUp);
                                    return false;
                                }
                                return true;
                            });
                        }
                        x += runLength;
                    } else {
                        x++;
                    }
                }
            }
            return linesCleared;
        }

        function relocatePowerUp(powerUp) {
            let newLocationFound = false;
            while (!newLocationFound) {
                let newX = Math.floor(Math.random() * gridWidth);
                let newY = Math.floor(Math.random() * gridHeight);
                if (
                    grid[newY][newX] === 0 &&
                    !snake.some(segment => segment.x === newX && segment.y === newY) &&
                    !powerUps.some(p => p.x === newX && p.y === newY)
                ) {
                    powerUp.x = newX;
                    powerUp.y = newY;
                    newLocationFound = true;
                }
            }
            powerUps.push(powerUp);
        }

        function draw() {
            context.fillStyle = '#000';
            context.fillRect(0, 0, canvas.width, canvas.height);

            drawMatrix(grid, { x: 0, y: 0 });

            drawGhostPiece(); // Draw ghost piece before current tetromino

            // Draw Tetris blocks over power-ups
            drawPowerUps();
            drawMatrix(tetrominoPlayer.matrix, tetrominoPlayer.pos, tetrominoPlayer.color);

            // Draw snake
            snake.forEach((segment, index) => {
                context.fillStyle = index === 0 ? '#FFD700' : '#FFFFFF'; // Head is gold, body is white
                context.fillRect(segment.x * blockSize, segment.y * blockSize, blockSize, blockSize);
            });

            // Indicate horizontal lines with 6 or more blocks
            indicateLines();

            // Draw warp timers outside the play area
            drawWarpTimers();
        }

        function drawMatrix(matrix, offset, color) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        context.fillStyle = color || '#FFFFFF';
                        context.fillRect(
                            (x + offset.x) * blockSize,
                            (y + offset.y) * blockSize,
                            blockSize,
                            blockSize
                        );
                    }
                });
            });
        }

        function indicateLines() {
            context.fillStyle = '#fff';
            context.font = '16px Arial';
            context.textAlign = 'center';
            context.textBaseline = 'middle';
            for (let y = 0; y < gridHeight; y++) {
                let x = 0;
                while (x < gridWidth) {
                    if (grid[y][x] !== 0) {
                        let runStart = x;
                        let runLength = 1;
                        while (x + runLength < gridWidth && grid[y][x + runLength] !== 0) {
                            runLength++;
                        }
                        if (runLength >= 6 && runLength < 12) {
                            let blocksNeeded = 12 - runLength;
                            // Show numbers on outer blocks
                            context.fillStyle = '#000';
                            context.fillText(blocksNeeded, (runStart + 0.5) * blockSize, (y + 0.5) * blockSize);
                            context.fillText(blocksNeeded, (x + runLength - 0.5) * blockSize, (y + 0.5) * blockSize);
                        }
                        x += runLength;
                    } else {
                        x++;
                    }
                }
            }
        }

        function drawWarpTimers() {
            const warpTimeDisplay = document.getElementById('warpTimeDisplay');
            let activeWarps = [];
            if (isFullWarpActive()) {
                let remainingTime = Math.ceil((fullWarpEndTime - Date.now()) / 1000);
                activeWarps.push(`Full Warp (${remainingTime}s left)`);
            } else {
                if (isSideWarpActive()) {
                    let remainingTime = Math.ceil((sideWarpEndTime - Date.now()) / 1000);
                    activeWarps.push(`Side Warp (${remainingTime}s left)`);
                }
                if (isVerticalWarpActive()) {
                    let remainingTime = Math.ceil((verticalWarpEndTime - Date.now()) / 1000);
                    activeWarps.push(`Vertical Warp (${remainingTime}s left)`);
                }
            }
            if (activeWarps.length > 0) {
                warpTimeDisplay.textContent = `Warp Time Left: ${activeWarps.join(', ')}`;
            } else {
                warpTimeDisplay.textContent = '';
            }
        }

        function drawGhostPiece() {
            let ghostPosition = { ...tetrominoPlayer.pos };
            while (!collide(grid, { pos: ghostPosition, matrix: tetrominoPlayer.matrix })) {
                ghostPosition.y++;
            }
            ghostPosition.y--; // Step back to last valid position

            context.globalAlpha = 0.5;
            drawMatrix(tetrominoPlayer.matrix, ghostPosition, 'grey'); // Draw ghost piece in grey
            context.globalAlpha = 1.0;
        }

        function drawPowerUps() {
            powerUps.forEach(powerUp => {
                context.fillStyle = powerUp.color;
                context.fillRect(powerUp.x * blockSize, powerUp.y * blockSize, blockSize, blockSize);
                context.fillStyle = '#000';
                context.font = '20px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(powerUp.symbol, (powerUp.x + 0.5) * blockSize, (powerUp.y + 0.5) * blockSize);
            });
        }

        // Draw Next Tetromino
        const nextBlockCanvas = document.getElementById('nextBlockCanvas');
        const nextBlockContext = nextBlockCanvas.getContext('2d');

        function drawNextTetromino() {
            nextBlockContext.fillStyle = '#000';
            nextBlockContext.fillRect(0, 0, nextBlockCanvas.width, nextBlockCanvas.height);

            if (nextTetromino) {
                const scale = 20;
                const offset = {
                    x: (nextBlockCanvas.width / 2) - (nextTetromino[0].length * scale) / 2,
                    y: (nextBlockCanvas.height / 2) - (nextTetromino.length * scale) / 2
                };
                nextTetromino.forEach((row, y) => {
                    row.forEach((value, x) => {
                        if (value !== 0) {
                            nextBlockContext.fillStyle = nextTetrominoColor;
                            nextBlockContext.fillRect(
                                offset.x + x * scale,
                                offset.y + y * scale,
                                scale,
                                scale
                            );
                        }
                    });
                });
            }
        }

        // Power-Up Functions
        function generatePowerUps() {
            // Generate multiple power-ups
            const currentTime = Date.now();
            const types = [
                { symbol: '↑', effect: 'increase', color: '#FFA500' }, // Orange
                { symbol: '↓', effect: 'decrease', color: '#FF0000' }, // Red
                { symbol: '?', effect: 'random', color: '#FFFF00' }    // Yellow
            ];

            // Warp Power-Ups, only one warp power-up can be on screen at a time
            const warpTypes = [
                { symbol: '⇄', effect: 'sideWarp', color: '#008000' }, // Green shades
                { symbol: '⇅', effect: 'verticalWarp', color: '#00A000' },
                { symbol: '⤡', effect: 'fullWarp', color: '#00C000' }
            ];

            // Check if warp power-up can be generated
            let canGenerateWarp = false;
            if (Date.now() - lastWarpPowerUpEndTime >= 90000 && !isWarpActive()) {
                canGenerateWarp = !powerUps.some(p => warpTypes.some(wt => wt.effect === p.effect));
            }

            // Generate power-ups
            powerUps = powerUps.filter(p => true); // Keep existing power-ups

            let numberOfPowerUps = 5 - powerUps.length;
            for (let i = 0; i < numberOfPowerUps; i++) {
                let powerUp;
                do {
                    let powerUpType;
                    if (canGenerateWarp && !powerUps.some(p => warpTypes.some(wt => wt.effect === p.effect))) {
                        // Include a warp power-up
                        powerUpType = warpTypes[Math.floor(Math.random() * warpTypes.length)];
                        canGenerateWarp = false; // Only one warp power-up
                    } else {
                        // Include a regular power-up
                        powerUpType = types[Math.floor(Math.random() * types.length)];
                    }

                    powerUp = {
                        x: Math.floor(Math.random() * gridWidth),
                        y: Math.floor(Math.random() * gridHeight),
                        ...powerUpType
                    };
                } while (
                    grid[powerUp.y][powerUp.x] !== 0 ||
                    snake.some(segment => segment.x === powerUp.x && segment.y === powerUp.y) ||
                    powerUps.some(p => p.x === powerUp.x && p.y === powerUp.y)
                );
                powerUps.push(powerUp);
            }
        }

        function isWarpActive() {
            return isSideWarpActive() || isVerticalWarpActive() || isFullWarpActive();
        }

        function checkPowerUpCollision(head) {
            for (let i = 0; i < powerUps.length; i++) {
                if (head.x === powerUps[i].x && head.y === powerUps[i].y) {
                    applyPowerUp(powerUps[i]);
                    powerUps.splice(i, 1);
                    generatePowerUps();
                    break;
                }
            }
        }

        function applyPowerUp(powerUp) {
            if (powerUp.effect === 'increase') {
                snakeLength = Math.ceil(snakeLength * 1.2);
                snakeScore += 2;
                updateScoreDisplays();
                showAlert('Snake length increased by 20%! +2 points');
            } else if (powerUp.effect === 'decrease') {
                snakeLength = Math.floor(snakeLength * 0.7);
                snakeScore -= 1;
                updateScoreDisplays();
                showAlert('Snake length decreased by 30%! -1 point');
            } else if (powerUp.effect === 'random') {
                const randomEffect = Math.random() < 0.5 ? 'increase' : 'decrease';
                if (randomEffect === 'increase') {
                    snakeLength = Math.ceil(snakeLength * 1.2);
                    snakeScore += 2;
                    updateScoreDisplays();
                    showAlert('Snake length increased by 20%! +2 points');
                } else {
                    snakeLength = Math.floor(snakeLength * 0.7);
                    snakeScore -= 1;
                    updateScoreDisplays();
                    showAlert('Snake length decreased by 30%! -1 point');
                }
            } else if (powerUp.effect === 'sideWarp') {
                sideWarpEndTime = Date.now() + powerUpDuration;
                lastWarpPowerUpEndTime = sideWarpEndTime;
                showAlert('Side Warp Activated! Wrap around side walls.');
            } else if (powerUp.effect === 'verticalWarp') {
                verticalWarpEndTime = Date.now() + powerUpDuration;
                lastWarpPowerUpEndTime = verticalWarpEndTime;
                showAlert('Vertical Warp Activated! Wrap around top and bottom walls.');
            } else if (powerUp.effect === 'fullWarp') {
                fullWarpEndTime = Date.now() + powerUpDuration;
                lastWarpPowerUpEndTime = fullWarpEndTime;
                showAlert('Full Warp Activated! Wrap around all walls.');
            }
            powerUpsCollected++;
            checkAchievements();
        }

        // Display Next Reward
        const nextRewardDiv = document.getElementById('nextReward');

        function updateNextRewardDisplay() {
            const pendingAchievements = Object.keys(achievements).filter(a => !achievements[a]);
            nextRewardDiv.textContent = pendingAchievements.length > 0 ? `Next Achievement: ${pendingAchievements[0]}` : 'All Achievements Unlocked!';
        }

        function updateScoreDisplays() {
            document.getElementById('tetrisScore').textContent = `Tetris Score: ${tetrominoPlayer.score}`;
            document.getElementById('snakeScore').textContent = `Snake Score: ${snakeScore}`;
        }

        function checkAchievements() {
            if (linesClearedTotal >= 5 && !achievements['Clear 5 Lines']) {
                achievements['Clear 5 Lines'] = true;
                showAlert('Achievement Unlocked: Clear 5 Lines!');
                updateNextRewardDisplay();
            }
            if (powerUpsCollected >= 10 && !achievements['Collect 10 Power-Ups']) {
                achievements['Collect 10 Power-Ups'] = true;
                showAlert('Achievement Unlocked: Collect 10 Power-Ups!');
                updateNextRewardDisplay();
            }
            if (snakeLength >= 20 && !achievements['Reach Snake Length of 20']) {
                achievements['Reach Snake Length of 20'] = true;
                showAlert('Achievement Unlocked: Reach Snake Length of 20!');
                updateNextRewardDisplay();
            }
            if (tetrominoPlayer.score >= 100 && !achievements['Score 100 Points']) {
                achievements['Score 100 Points'] = true;
                showAlert('Achievement Unlocked: Score 100 Points!');
                updateNextRewardDisplay();
            }
            if (linesClearedTotal >= 1 && !achievements['First Line Clear']) {
                achievements['First Line Clear'] = true;
                showAlert('Achievement Unlocked: First Line Clear!');
                updateNextRewardDisplay();
            }
        }

        // Score Board Management (Local Storage Version)
        function updateScoreBoard() {
            const totalScore = tetrominoPlayer.score + snakeScore;
            const dateTime = new Date().toLocaleString();

            const newScore = { name: playerName, score: totalScore, dateTime: dateTime };

            let scores = JSON.parse(localStorage.getItem('tetrisSnakeScores')) || [];
            scores.push(newScore);

            // Sort scores in descending order
            scores.sort((a, b) => b.score - a.score);

            // Keep only top 10 scores
            scores = scores.slice(0, 10);

            localStorage.setItem('tetrisSnakeScores', JSON.stringify(scores));
        }

        function loadScoreBoard() {
            const scoreTableBody = document.querySelector('#scoreTable tbody');
            scoreTableBody.innerHTML = ''; // Clear existing scores
            let scores = JSON.parse(localStorage.getItem('tetrisSnakeScores')) || [];
            scores.forEach(score => {
                const newRow = document.createElement('tr');

                const nameCell = document.createElement('td');
                nameCell.textContent = score.name;
                newRow.appendChild(nameCell);

                const scoreCell = document.createElement('td');
                scoreCell.textContent = score.score;
                newRow.appendChild(scoreCell);

                const dateCell = document.createElement('td');
                dateCell.textContent = score.dateTime;
                newRow.appendChild(dateCell);

                scoreTableBody.appendChild(newRow);
            });
        }

        // Start the game when "Start Game" button is clicked
        // resetGame(); // Will be called when "Start Game" is clicked
    </script>
</body>

</html>