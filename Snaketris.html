<!DOCTYPE html>
<html>

<head>
    <title>Tetris Snake Mashup</title>
    <style>
        body {
            background: #000;
            margin: 0;
            overflow: hidden;
            font-family: Arial, sans-serif;
            color: #fff;
        }

        canvas {
            display: block;
            margin: 20px auto;
            background: #111;
            border: 2px solid #4B0082;
            /* Dark Purple Outline */
        }

        #gameInfo {
            text-align: center;
        }

        #restartButton,
        #instructionsButton,
        #scoreBoardButton {
            display: inline-block;
            margin: 10px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #playerNameInput {
            display: block;
            margin: 10px auto;
            padding: 5px;
            font-size: 16px;
        }

        #instructionsModal,
        #scoreBoardModal,
        #keyBindingsModal,
        #achievementsModal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            color: #fff;
            display: none;
            align-items: center;
            justify-content: center;
        }

        #instructionsContent,
        #scoreBoardContent,
        #keyBindingsContent,
        #achievementsContent {
            background: #222;
            padding: 20px;
            border-radius: 10px;
            max-width: 80%;
            max-height: 80%;
            overflow-y: auto;
        }

        .closeModal {
            margin-top: 20px;
            padding: 10px 20px;
            font-size: 16px;
        }

        #alertBox {
            position: absolute;
            top: 10px;
            right: 10px;
            background: rgba(255, 0, 0, 0.7);
            color: #fff;
            padding: 10px;
            border-radius: 5px;
            display: none;
            font-size: 18px;
        }

        #controlsDiv {
            margin: 20px;
        }

        #controlsDiv label {
            display: inline-block;
            width: 150px;
            text-align: right;
            margin-right: 10px;
        }

        #controlsDiv input {
            width: 50px;
            text-align: center;
        }

        #nextReward,
        #nextPowerUp {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            font-size: 16px;
        }
    </style>
</head>

<body>
    <div id="gameInfo">
        <h1>Tetris Snake Mashup</h1>
        <canvas id="gameCanvas"></canvas>
        <input type="text" id="playerNameInput" placeholder="Enter your name" maxlength="20">
        <div>
            <button id="restartButton">Start Game</button>
            <button id="instructionsButton">Instructions</button>
            <button id="scoreBoardButton">Leaderboard</button>
            <button id="keyBindingsButton">Key Bindings</button>
            <button id="achievementsButton">Achievements</button>
        </div>
    </div>

    <!-- Instructions Modal -->
    <div id="instructionsModal">
        <div id="instructionsContent">
            <h2>Instructions</h2>
            <p><strong>Objective:</strong> Control both the snake and Tetris blocks simultaneously. Avoid collisions
                between the snake and Tetris blocks, including the falling block. Clear lines with Tetris blocks to earn
                points. Keep the snake alive to increase your snake score.</p>
            <h3>Controls</h3>
            <p><strong>Snake Controls:</strong> Arrow Keys or Mouse Pointer</p>
            <p><strong>Tetris Controls:</strong></p>
            <ul>
                <li><strong>Move Left/Right:</strong> <span id="leftKeyDisplay">A</span> / <span
                        id="rightKeyDisplay">D</span></li>
                <li><strong>Rotate:</strong> <span id="rotateCWKeyDisplay">W</span> (Clockwise) / <span
                        id="rotateCCWKeyDisplay">Q</span> (Counter-clockwise)</li>
                <li><strong>Soft Drop:</strong> Hold <span id="dropKeyDisplay">S</span> (Drops by blocks after holding)
                </li>
            </ul>
            <h3>Gameplay Mechanics</h3>
            <ul>
                <li>Tetris blocks change shape every time a new block comes down.</li>
                <li>Holding down the 'Soft Drop' key for 2 seconds will drop the Tetris block by 4 rows. For every
                    additional second held, it drops another 4 rows.</li>
                <li>The Tetris block drop speed increases by 1% each time a block is placed.</li>
                <li>The speed resets to the initial value when a new game starts.</li>
                <li>If the snake collides with any Tetris blocks (including the falling block), the game ends.</li>
                <li>Any consecutive horizontal line of 12 blocks or more will disappear and earn you points.</li>
                <li>Collect power-ups with the snake:</li>
                <ul>
                    <li><strong>Up Arrow (↑):</strong> Increases snake length by 20% and adds 2 points.</li>
                    <li><strong>Down Arrow (↓):</strong> Decreases snake length by 30% and subtracts 1 point.</li>
                    <li><strong>Question Mark (?):</strong> Randomly increases or decreases snake length.</li>
                </ul>
                <li>An alert appears when the snake is near collision with walls or Tetris blocks.</li>
                <li>Customize key bindings and control the snake with your mouse for a personalized experience.</li>
                <li>Unlock achievements by reaching specific milestones!</li>
            </ul>
            <h3>Game Over Conditions</h3>
            <ul>
                <li>Snake collides with walls, Tetris blocks (including the falling block), or itself.</li>
                <li>Tetris blocks reach the top and cannot be placed.</li>
            </ul>
            <button class="closeModal" id="closeInstructions">Close</button>
        </div>
    </div>

    <!-- Score Board Modal -->
    <div id="scoreBoardModal">
        <div id="scoreBoardContent">
            <h2>Leaderboard</h2>
            <table id="scoreTable">
                <thead>
                    <tr>
                        <th>Name</th>
                        <th>Score</th>
                        <th>Date & Time</th>
                    </tr>
                </thead>
                <tbody>
                    <!-- Scores will be populated here -->
                </tbody>
            </table>
            <button class="closeModal" id="closeScoreBoard">Close</button>
        </div>
    </div>

    <!-- Key Bindings Modal -->
    <div id="keyBindingsModal">
        <div id="keyBindingsContent">
            <h2>Customize Key Bindings</h2>
            <div id="controlsDiv">
                <div>
                    <label for="leftKey">Move Left:</label>
                    <input type="text" id="leftKey" maxlength="1" value="A">
                </div>
                <div>
                    <label for="rightKey">Move Right:</label>
                    <input type="text" id="rightKey" maxlength="1" value="D">
                </div>
                <div>
                    <label for="rotateCWKey">Rotate CW:</label>
                    <input type="text" id="rotateCWKey" maxlength="1" value="W">
                </div>
                <div>
                    <label for="rotateCCWKey">Rotate CCW:</label>
                    <input type="text" id="rotateCCWKey" maxlength="1" value="Q">
                </div>
                <div>
                    <label for="dropKey">Soft Drop:</label>
                    <input type="text" id="dropKey" maxlength="1" value="S">
                </div>
            </div>
            <button id="saveKeyBindings">Save</button>
            <button class="closeModal" id="closeKeyBindings">Close</button>
        </div>
    </div>

    <!-- Achievements Modal -->
    <div id="achievementsModal">
        <div id="achievementsContent">
            <h2>Achievements</h2>
            <ul id="achievementsList">
                <!-- Achievements will be populated here -->
            </ul>
            <button class="closeModal" id="closeAchievements">Close</button>
        </div>
    </div>

    <!-- Alert Box -->
    <div id="alertBox"></div>

    <!-- Next Reward and Power-Up Display -->
    <div id="nextReward">Next Achievement: First Line Clear</div>
    <div id="nextPowerUp">Next Power-Up: ? (Random Effect)</div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const context = canvas.getContext('2d');

        const gridWidth = 40; // 4 times wider
        const gridHeight = 20;
        const blockSize = 30;

        canvas.width = gridWidth * blockSize;
        canvas.height = gridHeight * blockSize;

        let grid = createMatrix(gridWidth, gridHeight);

        function createMatrix(w, h) {
            const matrix = [];
            while (h--) {
                matrix.push(new Array(w).fill(0));
            }
            return matrix;
        }

        // Rainbow colors for Tetris blocks
        const rainbowColors = [
            '#FF0000', // Red
            '#FF7F00', // Orange
            '#FFFF00', // Yellow
            '#00FF00', // Green
            '#0000FF', // Blue
            '#4B0082', // Indigo
            '#9400D3'  // Violet
        ];

        const tetrominoes = [
            [
                [1, 1, 1, 1]
            ],
            [
                [1, 0, 0],
                [1, 1, 1]
            ],
            [
                [0, 0, 1],
                [1, 1, 1]
            ],
            [
                [1, 1],
                [1, 1]
            ],
            [
                [0, 1, 1],
                [1, 1, 0]
            ],
            [
                [0, 1, 0],
                [1, 1, 1]
            ],
            [
                [1, 1, 0],
                [0, 1, 1]
            ]
        ];

        let tetrominoBag = [];

        function shuffle(array) {
            for (let i = array.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [array[i], array[j]] = [array[j], array[i]];
            }
        }

        let tetrominoPlayer = {
            pos: { x: 0, y: 0 },
            matrix: null,
            score: 0,
            color: '#FFFFFF', // Default color
            speed: 1000, // Initial drop interval in milliseconds
        };

        function tetrominoReset() {
            if (tetrominoBag.length === 0) {
                tetrominoBag = tetrominoes.slice();
                shuffle(tetrominoBag);
            }
            tetrominoPlayer.matrix = tetrominoBag.pop();
            tetrominoPlayer.pos.y = 0;
            tetrominoPlayer.pos.x = (gridWidth / 2 | 0) - (tetrominoPlayer.matrix[0].length / 2 | 0);
            tetrominoPlayer.color = rainbowColors[Math.floor(Math.random() * rainbowColors.length)];
            tetrominoPlayer.speed *= 0.99; // Increase speed by 1%

            if (collide(grid, tetrominoPlayer)) {
                gameOver = true;
                updateScoreBoard();
                alert('Game Over! Tetris block cannot be placed.');
            }
        }

        let snake = [{ x: Math.floor(gridWidth / 2), y: gridHeight - 1 }];
        let snakeDirection = { x: 0, y: -1 }; // Starts moving upwards
        let snakeNewDirection = { x: 0, y: -1 };
        let snakeScore = 0;
        let snakeLength = 5; // Initial snake length

        let powerUps = []; // Array to hold power-up icons

        function resetGame() {
            grid = createMatrix(gridWidth, gridHeight);
            tetrominoPlayer.score = 0;
            tetrominoPlayer.speed = 1000; // Reset speed
            snakeScore = 0;
            snakeLength = 5;
            tetrominoReset();
            snake = [{ x: Math.floor(gridWidth / 2), y: gridHeight - 1 }];
            snakeDirection = { x: 0, y: -1 };
            snakeNewDirection = { x: 0, y: -1 };
            powerUps = [];
            gameOver = false;
            lastTime = 0;
            dropCounter = 0;
            snakeMoveCounter = 0;
            dropKeyDown = false;
            dropKeyHoldTime = 0;
            achievements = {
                'First Line Clear': false,
                'Score 100 Points': false,
                'Survive 5 Minutes': false
            };
            achievementsUnlocked = [];
            gameStartTime = Date.now();
            generatePowerUps();
            updateNextPowerUpDisplay();
            updateNextRewardDisplay();
            requestAnimationFrame(update);
        }

        const restartButton = document.getElementById('restartButton');
        const playerNameInput = document.getElementById('playerNameInput');
        let playerName = '';

        restartButton.addEventListener('click', () => {
            playerName = playerNameInput.value.trim() || 'Player';
            resetGame();
        });

        // Instructions Modal
        const instructionsButton = document.getElementById('instructionsButton');
        const instructionsModal = document.getElementById('instructionsModal');
        const closeInstructions = document.getElementById('closeInstructions');

        instructionsButton.addEventListener('click', () => {
            updateKeyDisplay();
            instructionsModal.style.display = 'flex';
        });

        closeInstructions.addEventListener('click', () => {
            instructionsModal.style.display = 'none';
        });

        // Score Board Modal
        const scoreBoardButton = document.getElementById('scoreBoardButton');
        const scoreBoardModal = document.getElementById('scoreBoardModal');
        const closeScoreBoard = document.getElementById('closeScoreBoard');

        scoreBoardButton.addEventListener('click', () => {
            loadScoreBoard();
            scoreBoardModal.style.display = 'flex';
        });

        closeScoreBoard.addEventListener('click', () => {
            scoreBoardModal.style.display = 'none';
        });

        // Key Bindings Modal
        const keyBindingsButton = document.getElementById('keyBindingsButton');
        const keyBindingsModal = document.getElementById('keyBindingsModal');
        const closeKeyBindings = document.getElementById('closeKeyBindings');
        const saveKeyBindings = document.getElementById('saveKeyBindings');

        keyBindingsButton.addEventListener('click', () => {
            keyBindingsModal.style.display = 'flex';
        });

        closeKeyBindings.addEventListener('click', () => {
            keyBindingsModal.style.display = 'none';
        });

        saveKeyBindings.addEventListener('click', () => {
            leftKey = document.getElementById('leftKey').value.toLowerCase();
            rightKey = document.getElementById('rightKey').value.toLowerCase();
            rotateCWKey = document.getElementById('rotateCWKey').value.toLowerCase();
            rotateCCWKey = document.getElementById('rotateCCWKey').value.toLowerCase();
            dropKey = document.getElementById('dropKey').value.toLowerCase();
            updateKeyDisplay();
            keyBindingsModal.style.display = 'none';
        });

        function updateKeyDisplay() {
            document.getElementById('leftKeyDisplay').textContent = leftKey.toUpperCase();
            document.getElementById('rightKeyDisplay').textContent = rightKey.toUpperCase();
            document.getElementById('rotateCWKeyDisplay').textContent = rotateCWKey.toUpperCase();
            document.getElementById('rotateCCWKeyDisplay').textContent = rotateCCWKey.toUpperCase();
            document.getElementById('dropKeyDisplay').textContent = dropKey.toUpperCase();
        }

        // Achievements Modal
        const achievementsButton = document.getElementById('achievementsButton');
        const achievementsModal = document.getElementById('achievementsModal');
        const closeAchievements = document.getElementById('closeAchievements');
        const achievementsList = document.getElementById('achievementsList');

        achievementsButton.addEventListener('click', () => {
            loadAchievements();
            achievementsModal.style.display = 'flex';
        });

        closeAchievements.addEventListener('click', () => {
            achievementsModal.style.display = 'none';
        });

        function loadAchievements() {
            achievementsList.innerHTML = '';
            for (let [key, unlocked] of Object.entries(achievements)) {
                const listItem = document.createElement('li');
                listItem.textContent = `${key}: ${unlocked ? 'Unlocked' : 'Locked'}`;
                achievementsList.appendChild(listItem);
            }
        }

        // Alert Box
        const alertBox = document.getElementById('alertBox');
        let alertTimeout;

        let dropKeyDown = false;
        let dropKeyHoldTime = 0;

        // Default Key Bindings
        let leftKey = 'a';
        let rightKey = 'd';
        let rotateCWKey = 'w';
        let rotateCCWKey = 'q';
        let dropKey = 's';

        let achievements = {
            'First Line Clear': false,
            'Score 100 Points': false,
            'Survive 5 Minutes': false
        };

        let achievementsUnlocked = [];
        let gameStartTime = Date.now();

        document.addEventListener('keydown', event => {
            if (gameOver) return;

            const key = event.key.toLowerCase();

            // Snake Controls - Arrow Keys
            if (key === 'arrowleft') {
                if (snakeDirection.x !== 1) {
                    snakeNewDirection = { x: -1, y: 0 };
                }
            } else if (key === 'arrowup') {
                if (snakeDirection.y !== 1) {
                    snakeNewDirection = { x: 0, y: -1 };
                }
            } else if (key === 'arrowright') {
                if (snakeDirection.x !== -1) {
                    snakeNewDirection = { x: 1, y: 0 };
                }
            } else if (key === 'arrowdown') {
                if (snakeDirection.y !== -1) {
                    snakeNewDirection = { x: 0, y: 1 };
                }
            }

            // Tetris Controls
            else if (key === leftKey) {
                tetrominoMove(-1);
            } else if (key === rightKey) {
                tetrominoMove(1);
            } else if (key === rotateCWKey) {
                rotate(tetrominoPlayer.matrix, 1);
            } else if (key === rotateCCWKey) {
                rotate(tetrominoPlayer.matrix, -1);
            } else if (key === dropKey) {
                dropKeyDown = true;
                dropKeyHoldTime = Date.now();
            }
        });

        document.addEventListener('keyup', event => {
            const key = event.key.toLowerCase();
            if (key === dropKey) {
                dropKeyDown = false;
            }
        });

        // Mouse Control for Snake
        let mousePosition = { x: snake[0].x * blockSize, y: snake[0].y * blockSize };
        canvas.addEventListener('mousemove', event => {
            const rect = canvas.getBoundingClientRect();
            mousePosition = {
                x: event.clientX - rect.left,
                y: event.clientY - rect.top
            };
        });

        function tetrominoMove(dir) {
            tetrominoPlayer.pos.x += dir;
            if (collide(grid, tetrominoPlayer)) {
                tetrominoPlayer.pos.x -= dir;
            }
        }

        function tetrominoDrop() {
            tetrominoPlayer.pos.y++;
            if (collide(grid, tetrominoPlayer)) {
                tetrominoPlayer.pos.y--;
                merge(grid, tetrominoPlayer);
                tetrominoReset();
                let linesCleared = sweep();
                tetrominoPlayer.score += linesCleared * 10;

                if (linesCleared > 0 && !achievements['First Line Clear']) {
                    achievements['First Line Clear'] = true;
                    showAlert('Achievement Unlocked: First Line Clear!');
                    updateNextRewardDisplay();
                }

                if (tetrominoPlayer.score >= 100 && !achievements['Score 100 Points']) {
                    achievements['Score 100 Points'] = true;
                    showAlert('Achievement Unlocked: Score 100 Points!');
                    updateNextRewardDisplay();
                }
            }
            dropCounter = 0;
        }

        function rotate(matrix, dir) {
            // Create a deep copy of the matrix
            let rotated = JSON.parse(JSON.stringify(matrix));

            // Transpose the matrix
            for (let y = 0; y < rotated.length; ++y) {
                for (let x = 0; x < y; ++x) {
                    [rotated[x][y], rotated[y][x]] = [rotated[y][x], rotated[x][y]];
                }
            }
            // Reverse the rows for clockwise or columns for counter-clockwise rotation
            if (dir > 0) {
                rotated.forEach(row => row.reverse());
            } else {
                rotated.reverse();
            }

            const pos = tetrominoPlayer.pos.x;
            let offset = 1;
            while (collide(grid, { pos: tetrominoPlayer.pos, matrix: rotated })) {
                tetrominoPlayer.pos.x += offset;
                offset = -(offset + (offset > 0 ? 1 : -1));
                if (offset > rotated[0].length) {
                    tetrominoPlayer.pos.x = pos;
                    return;
                }
            }
            tetrominoPlayer.matrix = rotated;
        }

        let gameOver = false;
        let dropCounter = 0;
        let dropInterval = tetrominoPlayer.speed; // milliseconds

        let snakeMoveCounter = 0;
        let snakeMoveInterval = 200; // milliseconds

        let lastTime = 0;

        function update(time = 0) {
            const deltaTime = time - lastTime;
            lastTime = time;

            dropCounter += deltaTime;

            if (dropKeyDown) {
                const holdDuration = Date.now() - dropKeyHoldTime;
                if (holdDuration >= 2000) {
                    // After 2 seconds, drop by 4 rows
                    const drops = Math.floor((holdDuration - 2000) / 1000) + 1;
                    const totalDrops = 4 * drops;
                    for (let i = 0; i < totalDrops; i++) {
                        tetrominoPlayer.pos.y++;
                        if (collide(grid, tetrominoPlayer)) {
                            tetrominoPlayer.pos.y--;
                            merge(grid, tetrominoPlayer);
                            tetrominoReset();
                            let linesCleared = sweep();
                            tetrominoPlayer.score += linesCleared * 10;

                            if (linesCleared > 0 && !achievements['First Line Clear']) {
                                achievements['First Line Clear'] = true;
                                showAlert('Achievement Unlocked: First Line Clear!');
                                updateNextRewardDisplay();
                            }

                            if (tetrominoPlayer.score >= 100 && !achievements['Score 100 Points']) {
                                achievements['Score 100 Points'] = true;
                                showAlert('Achievement Unlocked: Score 100 Points!');
                                updateNextRewardDisplay();
                            }
                            break;
                        }
                    }
                    dropKeyHoldTime = Date.now(); // Reset to prevent multiple drops in the same frame
                    dropCounter = 0;
                }
            } else if (dropCounter > tetrominoPlayer.speed) {
                tetrominoDrop();
            }

            snakeMoveCounter += deltaTime;
            if (snakeMoveCounter > snakeMoveInterval) {
                snakeMoveCounter = 0;

                // Mouse Control
                const snakeHead = snake[0];
                const targetX = Math.floor(mousePosition.x / blockSize);
                const targetY = Math.floor(mousePosition.y / blockSize);
                const deltaX = targetX - snakeHead.x;
                const deltaY = targetY - snakeHead.y;

                if (Math.abs(deltaX) > Math.abs(deltaY)) {
                    snakeNewDirection = { x: deltaX > 0 ? 1 : -1, y: 0 };
                } else if (deltaY !== 0) {
                    snakeNewDirection = { x: 0, y: deltaY > 0 ? 1 : -1 };
                }

                if (snakeNewDirection.x !== -snakeDirection.x || snakeNewDirection.y !== -snakeDirection.y) {
                    snakeDirection = snakeNewDirection;
                }

                const newHead = { x: snakeHead.x + snakeDirection.x, y: snakeHead.y + snakeDirection.y };

                // Proximity Alert
                if (isNearCollision(newHead)) {
                    showAlert('Warning: Snake is near collision!');
                } else {
                    hideAlert();
                }

                if (
                    newHead.x < 0 ||
                    newHead.x >= gridWidth ||
                    newHead.y < 0 ||
                    newHead.y >= gridHeight ||
                    grid[newHead.y][newHead.x] !== 0 ||
                    snakeCollision(newHead) ||
                    tetrominoCollision(newHead)
                ) {
                    gameOver = true;
                    updateScoreBoard();
                    alert('Game Over! Snake collision detected.');
                } else {
                    snake.unshift(newHead);
                    if (snake.length > snakeLength) {
                        snake.pop();
                    } else {
                        snakeScore += 1;
                    }
                    checkPowerUpCollision(newHead);
                }

                // Achievement: Survive 5 Minutes
                if (!achievements['Survive 5 Minutes'] && (Date.now() - gameStartTime) >= 300000) {
                    achievements['Survive 5 Minutes'] = true;
                    showAlert('Achievement Unlocked: Survive 5 Minutes!');
                    updateNextRewardDisplay();
                }
            }

            draw();
            if (!gameOver) {
                requestAnimationFrame(update);
            }
        }

        function isNearCollision(head) {
            // Check if the snake is near the walls or Tetris blocks
            const directions = [
                { x: -1, y: 0 },
                { x: 1, y: 0 },
                { x: 0, y: -1 },
                { x: 0, y: 1 }
            ];
            for (let dir of directions) {
                const x = head.x + dir.x;
                const y = head.y + dir.y;
                if (
                    x < 0 ||
                    x >= gridWidth ||
                    y < 0 ||
                    y >= gridHeight ||
                    grid[y][x] !== 0 ||
                    tetrominoContainsCell(x, y)
                ) {
                    return true;
                }
            }
            return false;
        }

        function showAlert(message) {
            alertBox.textContent = message;
            alertBox.style.display = 'block';
            clearTimeout(alertTimeout);
            alertTimeout = setTimeout(() => {
                alertBox.style.display = 'none';
            }, 2000);
        }

        function hideAlert() {
            alertBox.style.display = 'none';
        }

        function snakeCollision(head) {
            for (let i = 1; i < snake.length; i++) {
                if (head.x === snake[i].x && head.y === snake[i].y) {
                    return true;
                }
            }
            return false;
        }

        function tetrominoCollision(head) {
            return tetrominoContainsCell(head.x, head.y);
        }

        function tetrominoContainsCell(x, y) {
            const m = tetrominoPlayer.matrix;
            const o = tetrominoPlayer.pos;
            for (let i = 0; i < m.length; ++i) {
                for (let j = 0; j < m[i].length; ++j) {
                    if (m[i][j] !== 0 && x === j + o.x && y === i + o.y) {
                        return true;
                    }
                }
            }
            return false;
        }

        function collide(grid, player) {
            const m = player.matrix;
            const o = player.pos;
            for (let y = 0; y < m.length; ++y) {
                for (let x = 0; x < m[y].length; ++x) {
                    if (
                        m[y][x] !== 0 &&
                        (grid[y + o.y] && grid[y + o.y][x + o.x]) !== 0
                    ) {
                        return true;
                    }
                }
            }
            return false;
        }

        function merge(grid, player) {
            player.matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        grid[y + player.pos.y][x + player.pos.x] = value;
                    }
                });
            });
        }

        function sweep() {
            let linesCleared = 0;
            for (let y = grid.length - 1; y >= 0; --y) {
                let x = 0;
                while (x < grid[y].length) {
                    if (grid[y][x] !== 0) {
                        let runLength = 1;
                        while (x + runLength < grid[y].length && grid[y][x + runLength] !== 0) {
                            runLength++;
                        }
                        if (runLength >= 12) {
                            // Remove blocks from x to x + runLength - 1
                            for (let k = x; k < x + runLength; k++) {
                                grid[y][k] = 0;
                            }
                            linesCleared++;
                        }
                        x += runLength;
                    } else {
                        x++;
                    }
                }
            }
            return linesCleared;
        }

        function draw() {
            context.fillStyle = '#000';
            context.fillRect(0, 0, canvas.width, canvas.height);

            drawMatrix(grid, { x: 0, y: 0 });
            drawMatrix(tetrominoPlayer.matrix, tetrominoPlayer.pos, tetrominoPlayer.color);

            // Draw power-ups
            powerUps.forEach(powerUp => {
                context.fillStyle = powerUp.color;
                context.fillRect(powerUp.x * blockSize, powerUp.y * blockSize, blockSize, blockSize);
                context.fillStyle = '#000';
                context.font = '20px Arial';
                context.textAlign = 'center';
                context.textBaseline = 'middle';
                context.fillText(powerUp.symbol, (powerUp.x + 0.5) * blockSize, (powerUp.y + 0.5) * blockSize);
            });

            // Draw snake
            snake.forEach((segment, index) => {
                context.fillStyle = index === 0 ? '#FFD700' : '#FFFFFF'; // Head is gold, body is white
                context.fillRect(segment.x * blockSize, segment.y * blockSize, blockSize, blockSize);
            });

            // Display Scores
            context.fillStyle = '#fff';
            context.font = '16px Arial';
            context.fillText(`Tetris Score: ${tetrominoPlayer.score}`, 10, 20);
            context.fillText(`Snake Score: ${snakeScore}`, 10, 40);
        }

        function drawMatrix(matrix, offset, color) {
            matrix.forEach((row, y) => {
                row.forEach((value, x) => {
                    if (value !== 0) {
                        context.fillStyle = color || '#FFFFFF';
                        context.fillRect(
                            (x + offset.x) * blockSize,
                            (y + offset.y) * blockSize,
                            blockSize,
                            blockSize
                        );
                    }
                });
            });
        }

        // Power-Up Functions
        function generatePowerUps() {
            powerUps = [];
            const types = [
                { symbol: '↑', effect: 'increase', color: '#00FF00' },
                { symbol: '↓', effect: 'decrease', color: '#FF0000' },
                { symbol: '?', effect: 'random', color: '#FFFF00' }
            ];
            for (let i = 0; i < 5; i++) {
                let powerUp;
                do {
                    powerUp = {
                        x: Math.floor(Math.random() * gridWidth),
                        y: Math.floor(Math.random() * gridHeight),
                        ...types[Math.floor(Math.random() * types.length)]
                    };
                } while (
                    grid[powerUp.y][powerUp.x] !== 0 ||
                    snake.some(segment => segment.x === powerUp.x && segment.y === powerUp.y)
                );
                powerUps.push(powerUp);
            }
            updateNextPowerUpDisplay();
        }

        function checkPowerUpCollision(head) {
            for (let i = 0; i < powerUps.length; i++) {
                if (head.x === powerUps[i].x && head.y === powerUps[i].y) {
                    applyPowerUp(powerUps[i]);
                    powerUps.splice(i, 1);
                    // Generate a new power-up
                    generatePowerUps();
                    break;
                }
            }
        }

        function applyPowerUp(powerUp) {
            if (powerUp.effect === 'increase') {
                snakeLength = Math.ceil(snakeLength * 1.2);
                snakeScore += 2;
                showAlert('Snake length increased by 20%! +2 points');
            } else if (powerUp.effect === 'decrease') {
                snakeLength = Math.floor(snakeLength * 0.7);
                snakeScore -= 1;
                showAlert('Snake length decreased by 30%! -1 point');
            } else if (powerUp.effect === 'random') {
                const randomEffect = Math.random() < 0.5 ? 'increase' : 'decrease';
                if (randomEffect === 'increase') {
                    snakeLength = Math.ceil(snakeLength * 1.2);
                    snakeScore += 2;
                    showAlert('Snake length increased by 20%! +2 points');
                } else {
                    snakeLength = Math.floor(snakeLength * 0.7);
                    snakeScore -= 1;
                    showAlert('Snake length decreased by 30%! -1 point');
                }
            }
            updateNextPowerUpDisplay();
        }

        // Display Next Reward and Power-Up
        const nextRewardDiv = document.getElementById('nextReward');
        const nextPowerUpDiv = document.getElementById('nextPowerUp');

        function updateNextRewardDisplay() {
            const pendingAchievements = Object.keys(achievements).filter(a => !achievements[a]);
            nextRewardDiv.textContent = pendingAchievements.length > 0 ? `Next Achievement: ${pendingAchievements[0]}` : 'All Achievements Unlocked!';
        }

        function updateNextPowerUpDisplay() {
            if (powerUps.length > 0) {
                const nextPowerUp = powerUps[0];
                nextPowerUpDiv.textContent = `Next Power-Up: ${nextPowerUp.symbol} (${nextPowerUp.effect.charAt(0).toUpperCase() + nextPowerUp.effect.slice(1)})`;
            } else {
                nextPowerUpDiv.textContent = 'No Power-Ups Available';
            }
        }

        // Score Board Management (Local Storage Version)
        function updateScoreBoard() {
            const totalScore = tetrominoPlayer.score + snakeScore;
            const dateTime = new Date().toLocaleString();

            const newScore = { name: playerName, score: totalScore, dateTime: dateTime };

            let scores = JSON.parse(localStorage.getItem('tetrisSnakeScores')) || [];
            scores.push(newScore);

            // Sort scores in descending order
            scores.sort((a, b) => b.score - a.score);

            // Keep only top 10 scores
            scores = scores.slice(0, 10);

            localStorage.setItem('tetrisSnakeScores', JSON.stringify(scores));
        }

        function loadScoreBoard() {
            const scoreTableBody = document.querySelector('#scoreTable tbody');
            scoreTableBody.innerHTML = ''; // Clear existing scores
            let scores = JSON.parse(localStorage.getItem('tetrisSnakeScores')) || [];
            scores.forEach(score => {
                const newRow = document.createElement('tr');

                const nameCell = document.createElement('td');
                nameCell.textContent = score.name;
                newRow.appendChild(nameCell);

                const scoreCell = document.createElement('td');
                scoreCell.textContent = score.score;
                newRow.appendChild(scoreCell);

                const dateCell = document.createElement('td');
                dateCell.textContent = score.dateTime;
                newRow.appendChild(dateCell);

                scoreTableBody.appendChild(newRow);
            });
        }

        // Start the game when "Start Game" button is clicked
        // resetGame();
    </script>
</body>

</html>